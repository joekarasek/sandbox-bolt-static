(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~bolt-video"],{

/***/ "./node_modules/@bolt/components-video/src/video.standalone.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@bolt/components-video/src/video.standalone.js ***!
  \*********************************************************************/
/*! exports provided: default, BoltVideo, BoltVideoMeta */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoltVideo\", function() { return BoltVideo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoltVideoMeta\", function() { return BoltVideoMeta; });\n/* harmony import */ var _bolt_core_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bolt/core/utils */ \"./node_modules/@bolt/core/utils/index.js\");\n/* harmony import */ var _bolt_core_renderers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bolt/core/renderers */ \"./node_modules/@bolt/core/renderers/index.js\");\n/* harmony import */ var dasherize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! dasherize */ \"./node_modules/dasherize/index.js\");\n/* harmony import */ var dasherize__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(dasherize__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var mousetrap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! mousetrap */ \"./node_modules/mousetrap/mousetrap.js\");\n/* harmony import */ var mousetrap__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(mousetrap__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _polymer_polymer_lib_utils_render_status_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @polymer/polymer/lib/utils/render-status.js */ \"./node_modules/@polymer/polymer/lib/utils/render-status.js\");\nvar _class, _class2, _temp, _class3, _class4, _temp2;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n // Bolt v2.0 will be shipping with this in Bolt core -- manually adding this in to the Bolt video player as a temp workaround till then.\n\n\nvar index = 0;\n\nvar BoltVideoMeta = Object(_bolt_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"define\"])(_class = (_temp = _class2 =\n/*#__PURE__*/\nfunction (_withPreact) {\n  _inherits(BoltVideoMeta, _withPreact);\n\n  function BoltVideoMeta(self) {\n    var _this;\n\n    _classCallCheck(this, BoltVideoMeta);\n\n    self = _this = _possibleConstructorReturn(this, _getPrototypeOf(BoltVideoMeta).call(this, self));\n    return _possibleConstructorReturn(_this, self);\n  }\n\n  _createClass(BoltVideoMeta, [{\n    key: \"render\",\n    value: function render() {\n      // All of its logic is contained here in render(), but it could be updated to be a property that is set\n      // externally (such as when the video has finished fully loading).\n      // [Mai] 'reveal' allows the meta data (title and duration) to be hidden.\n      var reveal = Boolean(this.title || this.duration);\n      return Object(_bolt_core_renderers__WEBPACK_IMPORTED_MODULE_1__[\"h\"])(\"div\", {\n        className: \"c-\".concat(\"bolt\", \"-video-meta\")\n      }, reveal ? Object(_bolt_core_renderers__WEBPACK_IMPORTED_MODULE_1__[\"h\"])(\"div\", {\n        className: \"c-\".concat(\"bolt\", \"-video-meta__wrapper\")\n      }, this.title ? Object(_bolt_core_renderers__WEBPACK_IMPORTED_MODULE_1__[\"h\"])(\"div\", {\n        className: \"c-\".concat(\"bolt\", \"-video-meta__item c-\").concat(\"bolt\", \"-video-meta__item--title\")\n      }, this.title) : null, Object(_bolt_core_renderers__WEBPACK_IMPORTED_MODULE_1__[\"h\"])(\"div\", {\n        className: \"c-\".concat(\"bolt\", \"-video-meta__item c-\").concat(\"bolt\", \"-video-meta__item--duration\")\n      }, this.duration)) : null);\n    }\n  }, {\n    key: \"renderRoot\",\n    get: function get() {\n      return this;\n    }\n  }]);\n\n  return BoltVideoMeta;\n}(Object(_bolt_core_renderers__WEBPACK_IMPORTED_MODULE_1__[\"withPreact\"])()), _class2.is = \"\".concat(\"bolt\", \"-video-meta\"), _class2.props = {\n  duration: _bolt_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"props\"].string,\n  title: _bolt_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"props\"].string\n}, _temp)) || _class;\n\nvar BoltVideo = Object(_bolt_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"define\"])(_class3 = (_temp2 = _class4 =\n/*#__PURE__*/\nfunction (_withPreact2) {\n  _inherits(BoltVideo, _withPreact2);\n\n  function BoltVideo(self) {\n    var _this2;\n\n    _classCallCheck(this, BoltVideo);\n\n    self = _this2 = _possibleConstructorReturn(this, _getPrototypeOf(BoltVideo).call(this, self));\n    index += 1;\n    _this2.onPlay = _this2.onPlay.bind(_assertThisInitialized(_assertThisInitialized(_this2)));\n    _this2.onPause = _this2.onPause.bind(_assertThisInitialized(_assertThisInitialized(_this2)));\n    _this2.onEnded = _this2.onEnded.bind(_assertThisInitialized(_assertThisInitialized(_this2))); // this.onProgress = this.onProgress.bind(this);\n\n    _this2.onDurationChange = _this2.onDurationChange.bind(_assertThisInitialized(_assertThisInitialized(_this2)));\n    _this2.onSeeked = _this2.onSeeked.bind(_assertThisInitialized(_assertThisInitialized(_this2))); // This binding is necessary to make `this` work in the callback\n\n    _this2.handleClose = _this2.handleClose.bind(_assertThisInitialized(_assertThisInitialized(_this2)));\n    _this2.collapseOnClickAway = _this2.collapseOnClickAway.bind(_assertThisInitialized(_assertThisInitialized(_this2))); // BoltVideo.globalErrors.forEach(this.props.onError);\n\n    _this2.defaultProps = {\n      // width: 320,\n      // height: 180,\n      // playerId: \"default\",\n      // onError: () => { },\n      // onPlay: () => { },\n      // onPause: () => { },\n      // onFinish: () => { },\n      // onProgress: () => { },\n      // onDuration: () => { },\n      loop: false,\n      autoplay: false,\n      hideFullScreenButton: false,\n      directToFullscreen: false,\n      resetOnFinish: false\n    }; // Ensure that 'this' inside the _onWindowResize event handler refers to <bolt-nav-link>\n    // even if the handler is attached to another element (window in this case)\n\n    _this2._onWindowResize = _this2._onWindowResize.bind(_assertThisInitialized(_assertThisInitialized(_this2)));\n    return _possibleConstructorReturn(_this2, self);\n  }\n\n  _createClass(BoltVideo, [{\n    key: \"_setMetaTitle\",\n    // Called to check whether or not the component should call\n    // updated(), much like React's shouldComponentUpdate().\n    // updating(props, state) {\n    //   console.log(props);\n    //   console.log(state);\n    // }\n    value: function _setMetaTitle(title) {\n      if (this.props.showMeta && this.props.showMetaTitle) {\n        this.querySelector(\"\".concat(\"bolt\", \"-video-meta\")).setAttribute('title', title);\n      }\n    }\n  }, {\n    key: \"_setMetaDuration\",\n    value: function _setMetaDuration(seconds) {\n      if (this.props.showMeta) {\n        var durationFormatted = BoltVideo._formatDuration(seconds);\n\n        this.querySelector(\"\".concat(\"bolt\", \"-video-meta\")).setAttribute('duration', durationFormatted);\n      }\n    }\n  }, {\n    key: \"_setVideoDimensions\",\n    value: function _setVideoDimensions(width, height) {\n      this.srcWidth = width;\n      this.srcHeight = height;\n    }\n  }, {\n    key: \"handleClose\",\n    // static isBackgroundVideo() {\n    //   return this.props.isBackgroundVideo;\n    // }\n    value: function handleClose() {\n      this.close();\n    }\n  }, {\n    key: \"connecting\",\n    value: function connecting() {\n      var _this3 = this;\n\n      this.state = {\n        // IDs can't start with numbers so adding the \"v\" prefix to prevent JS errors\n        id: \"v\".concat(this.props.videoId, \"-\").concat(this.props.accountId, \"-\").concat(index),\n        // errors: BoltVideo.globalErrors !== undefined  ? [].concat(BoltVideo.globalErrors) : [],\n        isPlaying: 'paused',\n        isFinished: false,\n        progress: 0\n      };\n\n      if (this.props.isBackgroundVideo) {\n        this._calculateIdealVideoSize();\n      }\n\n      if (this.defaultProps) {\n        var defaultProps = this.defaultProps;\n\n        for (var propName in defaultProps) {\n          if (this.props[propName] === undefined) {\n            this.props[propName] = defaultProps[propName];\n          }\n        }\n      }\n\n      if (BoltVideo.globalErrors !== undefined && BoltVideo.globalErrors.length) {\n        // console.log('adding default errors');\n        // console.log(this.state.errors);\n        this.state.errors = [].concat(BoltVideo.globalErrors);\n      } else {\n        this.state.errors = [];\n      }\n\n      if (this.state.errors.length) {\n        // console.log(this.state.errors);\n        // console.log('error length');\n        return;\n      } // only ever append script once\n\n\n      if (!BoltVideo.players) {\n        BoltVideo.players = [];\n        var s = this.createScript();\n\n        s.onload = function () {\n          BoltVideo.players.forEach(function (player) {\n            player.initVideoJS(player.state.id);\n          });\n        }; // handle script not loading\n\n\n        s.onerror = function (err) {\n          var uriErr = {\n            code: '',\n            message: \"The script \".concat(err.target.src, \" is not accessible.\")\n          };\n          BoltVideo.globalErrors.push(uriErr);\n\n          _this3.props.onError(uriErr);\n        };\n\n        BoltVideo.appendScript(s);\n      }\n\n      this.init(); // If onInit event exists on element, run that instead of auto initializing\n\n      if (this.props.onInit) {\n        if (window[this.props.onInit]) {\n          window[this.props.onInit](this);\n        }\n      } // If our video can expand/collapse we add the collapse listener and \"close on escape\" behavior\n\n\n      if (this.props.isBackgroundVideo) {\n        window.addEventListener('resize', this._onWindowResize);\n        mousetrap__WEBPACK_IMPORTED_MODULE_3___default.a.bind('esc', this.handleClose, 'keyup');\n        document.addEventListener('click', this.collapseOnClickAway);\n      }\n    }\n  }, {\n    key: \"_onWindowResize\",\n    value: function _onWindowResize(event) {\n      this._calculateIdealVideoSize();\n    } // If we click outside the video wrapper div collapse the video\n\n  }, {\n    key: \"collapseOnClickAway\",\n    value: function collapseOnClickAway(event) {\n      var videoWrapper = this.querySelector('.c-bolt-video--background');\n\n      if (!videoWrapper.contains(event.target)) {// @todo: debug why videos don't autoplay when this is enabled\n        // this.close();\n      }\n    } // shouldUpdate(props, state) {\n    //   return true;\n    // }\n    // Called when props have been set regardless of if they've changed.\n    // updating(props) { }\n\n    /**\n     * `attributeChangedCallback` processes changes to the `expanded` attribute.\n     */\n    // attributeChangedCallback(attributeName, oldValue, newValue) {\n    //   console.log(attributeName);\n    //   // `expanded` is a boolean attribute it is either set or not set. The\n    //   // actual value is irrelevant.\n    //   // const value = this.hasAttribute('expanded');\n    //   // this._shadowButton.setAttribute('aria-expanded', value);\n    // }\n\n  }, {\n    key: \"disconnecting\",\n    value: function disconnecting() {\n      if (this.props.isBackgroundVideo) {\n        window.removeEventListener('optimizedResize', this._onWindowResize);\n      }\n\n      if (this.player) {\n        this.player.dispose();\n      }\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(player) {\n      this.props.onError(player.error());\n    }\n  }, {\n    key: \"onPlay\",\n    value: function onPlay(player) {\n      this.classList.add('is-playing');\n      this.classList.remove('is-finished');\n      this.classList.remove('is-paused'); // @TODO: implement internal setState method\n      // elem.setState({\n      //   isPlaying: true,\n      //   progress: BoltVideo.getCurrentTimeMs(player),\n      //   isFinished: false\n      // });\n      // Dispatch an event that signals a request to expand to the\n      // `<howto-accordion>` element.\n\n      this.state.isPlaying = true;\n      this.state.progress = BoltVideo.getCurrentTimeMs(player);\n      this.state.isFinished = false;\n      this.dispatchEvent(new CustomEvent('playing', {\n        detail: {\n          isBackgroundVideo: this.props.isBackgroundVideo\n        },\n        bubbles: true\n      }));\n    }\n  }, {\n    key: \"onPause\",\n    value: function onPause(player) {\n      var progress = BoltVideo.getCurrentTimeMs(player);\n      this.classList.add('is-paused');\n      this.classList.remove('is-playing'); // @TODO: implement internal setState method\n      // this.setState({\n      //   isPlaying: false,\n      //   progress\n      // });\n\n      this.state.isPlaying = false;\n      this.state.progress = progress;\n      this.dispatchEvent(new CustomEvent('pause', {\n        detail: {\n          isBackgroundVideo: this.props.isBackgroundVideo\n        },\n        bubbles: true\n      }));\n    }\n  }, {\n    key: \"onSeeked\",\n    value: function onSeeked(player) {\n      var progress = BoltVideo.getCurrentTimeMs(player); // @TODO: implement internal setState method\n      // this.setState({\n      //   progress: BoltVideo.getCurrentTimeMs(player),\n      //   isFinished: false\n      // });\n\n      this.state.isFinished = false;\n      this.state.progress = progress;\n    }\n  }, {\n    key: \"onDurationChange\",\n    value: function onDurationChange(player) {\n      var duration = BoltVideo.getDurationMs(player); // @TODO: implement internal setState method\n      // this.setState({ duration: BoltVideo.getDurationMs(player) });\n\n      this.state.duration = duration;\n    }\n  }, {\n    key: \"onEnded\",\n    value: function onEnded() {\n      var _this4 = this;\n\n      // calling syncronously here inteferes with player and causes errors to be thrown\n      setTimeout(function () {\n        _this4.state.isFinished = true;\n\n        _this4.classList.add('is-finished');\n\n        _this4.classList.remove('is-paused');\n\n        _this4.dispatchEvent(new CustomEvent('ended', {\n          detail: {\n            isBackgroundVideo: _this4.props.isBackgroundVideo\n          },\n          bubbles: true\n        })); // this.setState({ isFinished: true });\n\n      }, 0);\n    }\n  }, {\n    key: \"_calculateIdealVideoSize\",\n    value: function _calculateIdealVideoSize() {\n      this.expandedHeight = this.getBoundingClientRect().height;\n    }\n  }, {\n    key: \"setPlayer\",\n    value: function setPlayer(player) {\n      this.player = player;\n    }\n  }, {\n    key: \"createScript\",\n    value: function createScript() {\n      var s = document.createElement('script');\n      s.src = BoltVideo.getScriptUrl(this.props.accountId, this.props.playerId);\n      s.async = true;\n      return s;\n    }\n  }, {\n    key: \"initVideoJS\",\n    value: function initVideoJS(id) {\n      var self = this;\n      Object(_polymer_polymer_lib_utils_render_status_js__WEBPACK_IMPORTED_MODULE_4__[\"beforeNextRender\"])(this, function () {\n        var player = videojs(id);\n        var handler = BoltVideo.handlePlayerReady.bind(player, self);\n        player.ready(handler);\n      });\n    }\n  }, {\n    key: \"initVideo\",\n    value: function initVideo(id) {\n      var self = this;\n      Object(_polymer_polymer_lib_utils_render_status_js__WEBPACK_IMPORTED_MODULE_4__[\"beforeNextRender\"])(this, function () {\n        bc(self.querySelector(\"#\".concat(id)), {\n          controlBar: {\n            fullscreenToggle: !self.props.hideFullScreenButton\n          }\n        });\n        self.initVideoJS(id);\n      });\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      var self = this;\n      Object(_polymer_polymer_lib_utils_render_status_js__WEBPACK_IMPORTED_MODULE_4__[\"beforeNextRender\"])(this, function () {\n        if (window.bc && window.videojs) {\n          self.initVideo(self.state.id);\n        } else {\n          BoltVideo.players.push(self);\n        }\n      });\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      if (this.player) {\n        this.player.play();\n      } else {\n        this.earlyPlay = true;\n        this.dispatchEvent(new CustomEvent('playing', {\n          detail: {\n            isBackgroundVideo: this.props.isBackgroundVideo\n          },\n          bubbles: true\n        }));\n      }\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.pause();\n      this.dispatchEvent(new CustomEvent('close', {\n        detail: {\n          isBackgroundVideo: this.props.isBackgroundVideo\n        },\n        bubbles: true\n      }));\n    }\n  }, {\n    key: \"toggle\",\n    value: function toggle() {\n      if (this.player) {\n        if (this.state.isPlaying === false || this.state.isPlaying === 'paused') {\n          this.play();\n        } else {\n          this.pause();\n        }\n      } else {\n        this.earlyToggle = true;\n        this.dispatchEvent(new CustomEvent('playing', {\n          detail: {\n            isBackgroundVideo: this.props.isBackgroundVideo\n          },\n          bubbles: true\n        }));\n      }\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (this.player) {\n        this.player.pause();\n      } else {\n        this.earlyPause = true;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render(_ref) {\n      var state = _ref.state,\n          props = _ref.props;\n\n      // console.log('render callback');\n      // data-email-subject=\"Pega - Intelligent Virtual Assistant for Email\"\n      // data-email-body=\"Check out this video from Pega\"\n      // data-email-videourl=\"https://local.d8.pega.com/insights/resources/intelligent-virtual-assistant-email\"\n      // const playIconEmoji = () => (\n      //   <span role=\"img\" aria-label=\"play-video\">\n      //     ▶️\n      //   </span>\n      // );\n\n      /* eslint jsx-a11y/media-has-caption: \"off\" */\n      // Added a wrapping div as brightcove adds siblings to the video tag\n      // Loop through any extra (unknown) data attributes on the main element; copy over to the <video> tag being rendered\n      function datasetToObject(elem) {\n        var data = {};\n        [].forEach.call(elem.attributes, function (attr) {\n          if (/^data-/.test(attr.name)) {\n            data[dasherize__WEBPACK_IMPORTED_MODULE_2___default()(attr.name)] = attr.value;\n          }\n        });\n        return data;\n      }\n\n      var dataAttributes = datasetToObject(this);\n      var closeButtonText = null;\n\n      if (this.props.closeButtonText) {\n        closeButtonText = this.props.closeButtonText;\n      } else {\n        closeButtonText = 'Close';\n      }\n\n      var classes = Object(_bolt_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"css\"])(\"c-\".concat(\"bolt\", \"-video\"), this.props.controls === false ? \"c-\".concat(\"bolt\", \"-video--hide-controls\") : '', this.props.isBackgroundVideo ? \"c-\".concat(\"bolt\", \"-video--background\") : '');\n      var videoMetaTag = \"\".concat(\"bolt\", \"-video-meta\");\n      return Object(_bolt_core_renderers__WEBPACK_IMPORTED_MODULE_1__[\"h\"])(\"span\", {\n        className: classes\n      }, Object(_bolt_core_renderers__WEBPACK_IMPORTED_MODULE_1__[\"h\"])(\"video\", _extends({}, dataAttributes, {\n        id: this.state.id\n      }, this.props.poster ? {\n        poster: this.props.poster.uri\n      } : {}, {\n        \"data-embed\": \"default\",\n        \"data-video-id\": this.props.videoId,\n        preload: \"none\",\n        \"data-account\": this.props.accountId,\n        \"data-player\": this.props.playerId // playIcon={playIconEmoji()}\n        // following 'autoplay' can not expected to always work on web\n        // see: https://docs.brightcove.com/en/player/brightcove-player/guides/in-page-embed-player-implementation.html\n        ,\n        autoPlay: this.props.autoplay,\n        \"data-application-id\": true,\n        loop: this.props.loop,\n        className: \"video-js\",\n        controls: this.props.controls === false ? false : true\n      })), this.props.showMeta && Object(_bolt_core_renderers__WEBPACK_IMPORTED_MODULE_1__[\"h\"])(videoMetaTag), this.props.isBackgroundVideo && Object(_bolt_core_renderers__WEBPACK_IMPORTED_MODULE_1__[\"h\"])(\"a\", {\n        className: Object(_bolt_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"css\"])(\"c-\".concat(\"bolt\", \"-video__close-button\"), \"c-\".concat(\"bolt\", \"-video__close-button--icon-to-text\")),\n        href: \"javascript:\",\n        onClick: this.handleClose\n      }, Object(_bolt_core_renderers__WEBPACK_IMPORTED_MODULE_1__[\"h\"])(\"span\", {\n        className: \"c-\".concat(\"bolt\", \"-video__close-button-icon\")\n      }, Object(_bolt_core_renderers__WEBPACK_IMPORTED_MODULE_1__[\"h\"])(\"div\", {\n        class: \"c-bolt-button c-bolt-button--xsmall c-bolt-button--secondary c-bolt-button--rounded c-bolt-button--icon-only\"\n      }, Object(_bolt_core_renderers__WEBPACK_IMPORTED_MODULE_1__[\"h\"])(\"span\", {\n        class: \"c-bolt-button__icon\"\n      }, Object(_bolt_core_renderers__WEBPACK_IMPORTED_MODULE_1__[\"h\"])(\"bolt-icon\", {\n        name: \"close\",\n        size: \"small\"\n      })))), Object(_bolt_core_renderers__WEBPACK_IMPORTED_MODULE_1__[\"h\"])(\"span\", {\n        className: \"c-\".concat(\"bolt\", \"-video__close-button-text\")\n      }, closeButtonText)));\n    }\n  }, {\n    key: \"renderRoot\",\n    get: function get() {\n      return this;\n    }\n  }, {\n    key: \"expandedHeight\",\n    get: function get() {\n      return this.getAttribute('expandedHeight');\n    }\n    /**\n     * Properties and their corresponding attributes should mirror one another.\n     * To this effect, the property setter for `expanded` handles truthy/falsy\n     * values and reflects those to the state of the attribute. It’s important\n     * to note that there are no side effects taking place in the property\n     * setter. For example, the setter does not set `aria-expanded`. Instead,\n     * that work happens in the `attributeChangedCallback`. As a general rule,\n     * make property setters very dumb, and if setting a property or attribute\n     * should cause a side effect (like setting a corresponding ARIA attribute)\n     * do that work in the `attributeChangedCallback`. This will avoid having to\n     * manage complex attribute/property reentrancy scenarios.\n     */\n    ,\n    set: function set(value) {\n      // Properties can be set to all kinds of string values. This makes sure\n      // it’s converted to a proper boolean value using JavaScript’s truthiness\n      // & falsiness principles.\n      // value = Boolean(value);\n      if (value) {\n        this.setAttribute('expandedHeight', value);\n      } else {\n        this.removeAttribute('expandedHeight');\n      }\n\n      this.dispatchEvent(new CustomEvent('videoExpandedHeightSet', {\n        detail: {\n          expandedHeight: this.expandedHeight\n        },\n        bubbles: true\n      }));\n    }\n  }], [{\n    key: \"_formatDuration\",\n    value: function _formatDuration(seconds) {\n      var mm = Math.floor(seconds / 60) || 0;\n      var ss = ('0' + Math.floor(seconds % 60)).slice(-2);\n      return mm + ':' + ss;\n    }\n  }, {\n    key: \"handlePlayerReady\",\n    value: function handlePlayerReady(context) {\n      var player = this;\n      var elem = context;\n      elem.setPlayer(player); // If the option to show controls is set to false (meaning, no controls will be shown), make sure the video is also muted.\n\n      if (elem.controls === false) {\n        elem.player.muted(true);\n      }\n\n      player.on('loadedmetadata', function () {\n        var duration = player.mediainfo.duration;\n        var title = player.mediainfo.name;\n        var width = player.mediainfo.sources[1].width;\n        var height = player.mediainfo.sources[1].height;\n\n        elem._setMetaTitle(title);\n\n        elem._setMetaDuration(duration);\n\n        elem._setVideoDimensions(width, height);\n\n        if (this.earlyToggle) {\n          this.earlyToggle = false;\n          this.toggle();\n        } else if (this.earlyPlay) {\n          this.earlyPlay = false;\n          this.play();\n        } else if (this.earlyPause) {\n          this.earlyPause = false;\n          this.pause();\n        }\n      });\n      player.on('play', function () {\n        elem.onPlay(player);\n      });\n      player.on('pause', function () {\n        elem.onPause(player);\n      });\n      player.on('seeked', function () {\n        elem.onSeeked(player);\n      });\n      player.on('timeupdate', function () {// elem.onPlay(player);\n      });\n      player.on('durationchange', function () {\n        elem.onDurationChange(player);\n      });\n      player.on('ended', function () {\n        elem.onEnded(player);\n      }); // this.contextmenu({ disabled: true });\n    }\n  }, {\n    key: \"appendScript\",\n    value: function appendScript(s) {\n      document.body.appendChild(s);\n    }\n  }, {\n    key: \"getScriptUrl\",\n    value: function getScriptUrl(accountId, playerId) {\n      return \"//players.brightcove.net/\".concat(accountId, \"/\").concat(playerId, \"_default/index.min.js\");\n    }\n  }, {\n    key: \"getCurrentTimeMs\",\n    value: function getCurrentTimeMs(player) {\n      return Math.round(player.currentTime() * 1000);\n    }\n  }, {\n    key: \"getDurationMs\",\n    value: function getDurationMs(player) {\n      return Math.round(player.duration() * 1000);\n    }\n  }]);\n\n  return BoltVideo;\n}(Object(_bolt_core_renderers__WEBPACK_IMPORTED_MODULE_1__[\"withPreact\"])()), _class4.is = \"\".concat(\"bolt\", \"-video\"), _class4.props = {\n  videoId: _bolt_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"props\"].string,\n  accountId: _bolt_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"props\"].string,\n  playerId: _bolt_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"props\"].string,\n  poster: _bolt_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"props\"].object,\n  isBackgroundVideo: _bolt_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"props\"].boolean,\n  onInit: _bolt_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"props\"].string,\n  showMeta: _bolt_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"props\"].boolean,\n  showMetaTitle: _bolt_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"props\"].boolean,\n  closeButtonText: _bolt_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"props\"].string,\n  loop: _bolt_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"props\"].boolean,\n  // onError: null,\n  // onPlay: null,\n  // onPause: null,\n  // onFinish: null,\n  // onProgress: null,\n  // onDuration: null,\n  controls: _bolt_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"props\"].boolean,\n  autoplay: _bolt_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"props\"].boolean,\n  resetOnFinish: _bolt_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"props\"].boolean,\n  directToFullscreen: _bolt_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"props\"].boolean,\n  hideFullScreenButton: _bolt_core_utils__WEBPACK_IMPORTED_MODULE_0__[\"props\"].boolean\n}, _temp2)) || _class3;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (BoltVideo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJvbHQvY29tcG9uZW50cy12aWRlby9zcmMvdmlkZW8uc3RhbmRhbG9uZS5qcz8zYzU4Il0sIm5hbWVzIjpbImluZGV4IiwiQm9sdFZpZGVvTWV0YSIsImRlZmluZSIsInNlbGYiLCJyZXZlYWwiLCJCb29sZWFuIiwidGl0bGUiLCJkdXJhdGlvbiIsImJvbHQiLCJ3aXRoUHJlYWN0IiwiaXMiLCJwcm9wcyIsInN0cmluZyIsIkJvbHRWaWRlbyIsIm9uUGxheSIsImJpbmQiLCJvblBhdXNlIiwib25FbmRlZCIsIm9uRHVyYXRpb25DaGFuZ2UiLCJvblNlZWtlZCIsImhhbmRsZUNsb3NlIiwiY29sbGFwc2VPbkNsaWNrQXdheSIsImRlZmF1bHRQcm9wcyIsImxvb3AiLCJhdXRvcGxheSIsImhpZGVGdWxsU2NyZWVuQnV0dG9uIiwiZGlyZWN0VG9GdWxsc2NyZWVuIiwicmVzZXRPbkZpbmlzaCIsIl9vbldpbmRvd1Jlc2l6ZSIsInNob3dNZXRhIiwic2hvd01ldGFUaXRsZSIsInF1ZXJ5U2VsZWN0b3IiLCJzZXRBdHRyaWJ1dGUiLCJzZWNvbmRzIiwiZHVyYXRpb25Gb3JtYXR0ZWQiLCJfZm9ybWF0RHVyYXRpb24iLCJ3aWR0aCIsImhlaWdodCIsInNyY1dpZHRoIiwic3JjSGVpZ2h0IiwiY2xvc2UiLCJzdGF0ZSIsImlkIiwidmlkZW9JZCIsImFjY291bnRJZCIsImlzUGxheWluZyIsImlzRmluaXNoZWQiLCJwcm9ncmVzcyIsImlzQmFja2dyb3VuZFZpZGVvIiwiX2NhbGN1bGF0ZUlkZWFsVmlkZW9TaXplIiwicHJvcE5hbWUiLCJ1bmRlZmluZWQiLCJnbG9iYWxFcnJvcnMiLCJsZW5ndGgiLCJlcnJvcnMiLCJjb25jYXQiLCJwbGF5ZXJzIiwicyIsImNyZWF0ZVNjcmlwdCIsIm9ubG9hZCIsImZvckVhY2giLCJwbGF5ZXIiLCJpbml0VmlkZW9KUyIsIm9uZXJyb3IiLCJlcnIiLCJ1cmlFcnIiLCJjb2RlIiwibWVzc2FnZSIsInRhcmdldCIsInNyYyIsInB1c2giLCJvbkVycm9yIiwiYXBwZW5kU2NyaXB0IiwiaW5pdCIsIm9uSW5pdCIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJNb3VzZXRyYXAiLCJkb2N1bWVudCIsImV2ZW50IiwidmlkZW9XcmFwcGVyIiwiY29udGFpbnMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGlzcG9zZSIsImVycm9yIiwiY2xhc3NMaXN0IiwiYWRkIiwicmVtb3ZlIiwiZ2V0Q3VycmVudFRpbWVNcyIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21FdmVudCIsImRldGFpbCIsImJ1YmJsZXMiLCJnZXREdXJhdGlvbk1zIiwic2V0VGltZW91dCIsImV4cGFuZGVkSGVpZ2h0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY3JlYXRlRWxlbWVudCIsImdldFNjcmlwdFVybCIsInBsYXllcklkIiwiYXN5bmMiLCJiZWZvcmVOZXh0UmVuZGVyIiwidmlkZW9qcyIsImhhbmRsZXIiLCJoYW5kbGVQbGF5ZXJSZWFkeSIsInJlYWR5IiwiYmMiLCJjb250cm9sQmFyIiwiZnVsbHNjcmVlblRvZ2dsZSIsImluaXRWaWRlbyIsInBsYXkiLCJlYXJseVBsYXkiLCJwYXVzZSIsImVhcmx5VG9nZ2xlIiwiZWFybHlQYXVzZSIsImRhdGFzZXRUb09iamVjdCIsImVsZW0iLCJkYXRhIiwiY2FsbCIsImF0dHJpYnV0ZXMiLCJhdHRyIiwidGVzdCIsIm5hbWUiLCJkYXNoZXJpemUiLCJ2YWx1ZSIsImRhdGFBdHRyaWJ1dGVzIiwiY2xvc2VCdXR0b25UZXh0IiwiY2xhc3NlcyIsImNzcyIsImNvbnRyb2xzIiwidmlkZW9NZXRhVGFnIiwicG9zdGVyIiwidXJpIiwiaCIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm1tIiwiTWF0aCIsImZsb29yIiwic3MiLCJzbGljZSIsImNvbnRleHQiLCJzZXRQbGF5ZXIiLCJtdXRlZCIsIm9uIiwibWVkaWFpbmZvIiwic291cmNlcyIsIl9zZXRNZXRhVGl0bGUiLCJfc2V0TWV0YUR1cmF0aW9uIiwiX3NldFZpZGVvRGltZW5zaW9ucyIsInRvZ2dsZSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInJvdW5kIiwiY3VycmVudFRpbWUiLCJvYmplY3QiLCJib29sZWFuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtDQUdBOztBQUNBO0FBRUEsSUFBSUEsS0FBSyxHQUFHLENBQVo7O0lBR01DLGEsR0FETEMsK0Q7Ozs7O0FBSUMseUJBQVlDLElBQVosRUFBa0I7QUFBQTs7QUFBQTs7QUFDaEJBLFFBQUksc0ZBQVNBLElBQVQsRUFBSjtBQUNBLDZDQUFPQSxJQUFQO0FBQ0Q7Ozs7NkJBV1E7QUFDUDtBQUNBO0FBRUE7QUFDQSxVQUFNQyxNQUFNLEdBQUdDLE9BQU8sQ0FBQyxLQUFLQyxLQUFMLElBQWMsS0FBS0MsUUFBcEIsQ0FBdEI7QUFDQSxhQUNFO0FBQUssaUJBQVMsY0FBT0MsTUFBUDtBQUFkLFNBQ0dKLE1BQU0sR0FDTDtBQUFLLGlCQUFTLGNBQU9JLE1BQVA7QUFBZCxTQUNHLEtBQUtGLEtBQUwsR0FDQztBQUNFLGlCQUFTLGNBQU9FLE1BQVAsaUNBQ1BBLE1BRE87QUFEWCxTQUlHLEtBQUtGLEtBSlIsQ0FERCxHQU9HLElBUk4sRUFTRTtBQUNFLGlCQUFTLGNBQU9FLE1BQVAsaUNBQ1BBLE1BRE87QUFEWCxTQUlHLEtBQUtELFFBSlIsQ0FURixDQURLLEdBaUJILElBbEJOLENBREY7QUFzQkQ7Ozt3QkFoQ2dCO0FBQ2YsYUFBTyxJQUFQO0FBQ0Q7Ozs7RUFmeUJFLHVFQUFVLEUsV0FDN0JDLEUsYUFBUUYsTSwwQkFPUkcsSyxHQUFRO0FBQ2JKLFVBQVEsRUFBRUksc0RBQUssQ0FBQ0MsTUFESDtBQUViTixPQUFLLEVBQUVLLHNEQUFLLENBQUNDO0FBRkEsQzs7SUF5Q1hDLFMsR0FETFgsK0Q7Ozs7O0FBNEJDLHFCQUFZQyxJQUFaLEVBQWtCO0FBQUE7O0FBQUE7O0FBQ2hCQSxRQUFJ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RUE3TnFCRSx1RUFBVSxFLFdBQ3pCQyxFLGFBQVFGLE0scUJBRVJHLEssR0FBUTtBQUNiZ0MsU0FBTyxFQUFFaEMsc0RBQUssQ0FBQ0MsTUFERjtBQUViZ0MsV0FBUyxFQUFFakMsc0RBQUssQ0FBQ0MsTUFGSjtBQUdidUYsVUFBUSxFQUFFeEYsc0RBQUssQ0FBQ0MsTUFISDtBQUlidUgsUUFBTSxFQUFFeEgsc0RBQUssQ0FBQ2dKLE1BSkQ7QUFLYjNHLG1CQUFpQixFQUFFckMsc0RBQUssQ0FBQ2lKLE9BTFo7QUFNYmxGLFFBQU0sRUFBRS9ELHNEQUFLLENBQUNDLE1BTkQ7QUFPYmlCLFVBQVEsRUFBRWxCLHNEQUFLLENBQUNpSixPQVBIO0FBUWI5SCxlQUFhLEVBQUVuQixzREFBSyxDQUFDaUosT0FSUjtBQVNiOUIsaUJBQWUsRUFBRW5ILHNEQUFLLENBQUNDLE1BVFY7QUFVYlcsTUFBSSxFQUFFWixzREFBSyxDQUFDaUosT0FWQztBQVdiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBM0IsVUFBUSxFQUFFdEgsc0RBQUssQ0FBQ2lKLE9BakJIO0FBa0JicEksVUFBUSxFQUFFYixzREFBSyxDQUFDaUosT0FsQkg7QUFtQmJqSSxlQUFhLEVBQUVoQixzREFBSyxDQUFDaUosT0FuQlI7QUFvQmJsSSxvQkFBa0IsRUFBRWYsc0RBQUssQ0FBQ2lKLE9BcEJiO0FBcUJibkksc0JBQW9CLEVBQUVkLHNEQUFLLENBQUNpSjtBQXJCZixDOztBQTRvQkYvSSx3RUFBZiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AYm9sdC9jb21wb25lbnRzLXZpZGVvL3NyYy92aWRlby5zdGFuZGFsb25lLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmaW5lLCBwcm9wcywgY3NzIH0gZnJvbSAnQGJvbHQvY29yZS91dGlscyc7XG5pbXBvcnQgeyBoLCB3aXRoUHJlYWN0IH0gZnJvbSAnQGJvbHQvY29yZS9yZW5kZXJlcnMnO1xuaW1wb3J0IGRhc2hlcml6ZSBmcm9tICdkYXNoZXJpemUnO1xuaW1wb3J0IE1vdXNldHJhcCBmcm9tICdtb3VzZXRyYXAnO1xuXG4vLyBCb2x0IHYyLjAgd2lsbCBiZSBzaGlwcGluZyB3aXRoIHRoaXMgaW4gQm9sdCBjb3JlIC0tIG1hbnVhbGx5IGFkZGluZyB0aGlzIGluIHRvIHRoZSBCb2x0IHZpZGVvIHBsYXllciBhcyBhIHRlbXAgd29ya2Fyb3VuZCB0aWxsIHRoZW4uXG5pbXBvcnQgeyBiZWZvcmVOZXh0UmVuZGVyIH0gZnJvbSAnQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvcmVuZGVyLXN0YXR1cy5qcyc7XG5cbmxldCBpbmRleCA9IDA7XG5cbkBkZWZpbmVcbmNsYXNzIEJvbHRWaWRlb01ldGEgZXh0ZW5kcyB3aXRoUHJlYWN0KCkge1xuICBzdGF0aWMgaXMgPSBgJHtib2x0Lm5hbWVzcGFjZX0tdmlkZW8tbWV0YWA7XG5cbiAgY29uc3RydWN0b3Ioc2VsZikge1xuICAgIHNlbGYgPSBzdXBlcihzZWxmKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIHN0YXRpYyBwcm9wcyA9IHtcbiAgICBkdXJhdGlvbjogcHJvcHMuc3RyaW5nLFxuICAgIHRpdGxlOiBwcm9wcy5zdHJpbmcsXG4gIH07XG5cbiAgZ2V0IHJlbmRlclJvb3QoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgLy8gQWxsIG9mIGl0cyBsb2dpYyBpcyBjb250YWluZWQgaGVyZSBpbiByZW5kZXIoKSwgYnV0IGl0IGNvdWxkIGJlIHVwZGF0ZWQgdG8gYmUgYSBwcm9wZXJ0eSB0aGF0IGlzIHNldFxuICAgIC8vIGV4dGVybmFsbHkgKHN1Y2ggYXMgd2hlbiB0aGUgdmlkZW8gaGFzIGZpbmlzaGVkIGZ1bGx5IGxvYWRpbmcpLlxuXG4gICAgLy8gW01haV0gJ3JldmVhbCcgYWxsb3dzIHRoZSBtZXRhIGRhdGEgKHRpdGxlIGFuZCBkdXJhdGlvbikgdG8gYmUgaGlkZGVuLlxuICAgIGNvbnN0IHJldmVhbCA9IEJvb2xlYW4odGhpcy50aXRsZSB8fCB0aGlzLmR1cmF0aW9uKTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e2BjLSR7Ym9sdC5uYW1lc3BhY2V9LXZpZGVvLW1ldGFgfT5cbiAgICAgICAge3JldmVhbCA/IChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YGMtJHtib2x0Lm5hbWVzcGFjZX0tdmlkZW8tbWV0YV9fd3JhcHBlcmB9PlxuICAgICAgICAgICAge3RoaXMudGl0bGUgPyAoXG4gICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2BjLSR7Ym9sdC5uYW1lc3BhY2V9LXZpZGVvLW1ldGFfX2l0ZW0gYy0ke1xuICAgICAgICAgICAgICAgICAgYm9sdC5uYW1lc3BhY2VcbiAgICAgICAgICAgICAgICB9LXZpZGVvLW1ldGFfX2l0ZW0tLXRpdGxlYH0+XG4gICAgICAgICAgICAgICAge3RoaXMudGl0bGV9XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKSA6IG51bGx9XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17YGMtJHtib2x0Lm5hbWVzcGFjZX0tdmlkZW8tbWV0YV9faXRlbSBjLSR7XG4gICAgICAgICAgICAgICAgYm9sdC5uYW1lc3BhY2VcbiAgICAgICAgICAgICAgfS12aWRlby1tZXRhX19pdGVtLS1kdXJhdGlvbmB9PlxuICAgICAgICAgICAgICB7dGhpcy5kdXJhdGlvbn1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApIDogbnVsbH1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuQGRlZmluZVxuY2xhc3MgQm9sdFZpZGVvIGV4dGVuZHMgd2l0aFByZWFjdCgpIHtcbiAgc3RhdGljIGlzID0gYCR7Ym9sdC5uYW1lc3BhY2V9LXZpZGVvYDtcblxuICBzdGF0aWMgcHJvcHMgPSB7XG4gICAgdmlkZW9JZDogcHJvcHMuc3RyaW5nLFxuICAgIGFjY291bnRJZDogcHJvcHMuc3RyaW5nLFxuICAgIHBsYXllcklkOiBwcm9wcy5zdHJpbmcsXG4gICAgcG9zdGVyOiBwcm9wcy5vYmplY3QsXG4gICAgaXNCYWNrZ3JvdW5kVmlkZW86IHByb3BzLmJvb2xlYW4sXG4gICAgb25Jbml0OiBwcm9wcy5zdHJpbmcsXG4gICAgc2hvd01ldGE6IHByb3BzLmJvb2xlYW4sXG4gICAgc2hvd01ldGFUaXRsZTogcHJvcHMuYm9vbGVhbixcbiAgICBjbG9zZUJ1dHRvblRleHQ6IHByb3BzLnN0cmluZyxcbiAgICBsb29wOiBwcm9wcy5ib29sZWFuLFxuICAgIC8vIG9uRXJyb3I6IG51bGwsXG4gICAgLy8gb25QbGF5OiBudWxsLFxuICAgIC8vIG9uUGF1c2U6IG51bGwsXG4gICAgLy8gb25GaW5pc2g6IG51bGwsXG4gICAgLy8gb25Qcm9ncmVzczogbnVsbCxcbiAgICAvLyBvbkR1cmF0aW9uOiBudWxsLFxuICAgIGNvbnRyb2xzOiBwcm9wcy5ib29sZWFuLFxuICAgIGF1dG9wbGF5OiBwcm9wcy5ib29sZWFuLFxuICAgIHJlc2V0T25GaW5pc2g6IHByb3BzLmJvb2xlYW4sXG4gICAgZGlyZWN0VG9GdWxsc2NyZWVuOiBwcm9wcy5ib29sZWFuLFxuICAgIGhpZGVGdWxsU2NyZWVuQnV0dG9uOiBwcm9wcy5ib29sZWFuLFxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHNlbGYpIHtcbiAgICBzZWxmID0gc3VwZXIoc2VsZik7XG5cbiAgICBpbmRleCArPSAxO1xuXG4gICAgdGhpcy5vblBsYXkgPSB0aGlzLm9uUGxheS5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25QYXVzZSA9IHRoaXMub25QYXVzZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25FbmRlZCA9IHRoaXMub25FbmRlZC5iaW5kKHRoaXMpO1xuICAgIC8vIHRoaXMub25Qcm9ncmVzcyA9IHRoaXMub25Qcm9ncmVzcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25EdXJhdGlvbkNoYW5nZSA9IHRoaXMub25EdXJhdGlvbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25TZWVrZWQgPSB0aGlzLm9uU2Vla2VkLmJpbmQodGhpcyk7XG5cbiAgICAvLyBUaGlzIGJpbmRpbmcgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgYHRoaXNgIHdvcmsgaW4gdGhlIGNhbGxiYWNrXG4gICAgdGhpcy5oYW5kbGVDbG9zZSA9IHRoaXMuaGFuZGxlQ2xvc2UuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuY29sbGFwc2VPbkNsaWNrQXdheSA9IHRoaXMuY29sbGFwc2VPbkNsaWNrQXdheS5iaW5kKHRoaXMpO1xuXG4gICAgLy8gQm9sdFZpZGVvLmdsb2JhbEVycm9ycy5mb3JFYWNoKHRoaXMucHJvcHMub25FcnJvcik7XG5cbiAgICB0aGlzLmRlZmF1bHRQcm9wcyA9IHtcbiAgICAgIC8vIHdpZHRoOiAzMjAsXG4gICAgICAvLyBoZWlnaHQ6IDE4MCxcbiAgICAgIC8vIHBsYXllcklkOiBcImRlZmF1bHRcIixcbiAgICAgIC8vIG9uRXJyb3I6ICgpID0+IHsgfSxcbiAgICAgIC8vIG9uUGxheTogKCkgPT4geyB9LFxuICAgICAgLy8gb25QYXVzZTogKCkgPT4geyB9LFxuICAgICAgLy8gb25GaW5pc2g6ICgpID0+IHsgfSxcbiAgICAgIC8vIG9uUHJvZ3Jlc3M6ICgpID0+IHsgfSxcbiAgICAgIC8vIG9uRHVyYXRpb246ICgpID0+IHsgfSxcbiAgICAgIGxvb3A6IGZhbHNlLFxuICAgICAgYXV0b3BsYXk6IGZhbHNlLFxuICAgICAgaGlkZUZ1bGxTY3JlZW5CdXR0b246IGZhbHNlLFxuICAgICAgZGlyZWN0VG9GdWxsc2NyZWVuOiBmYWxzZSxcbiAgICAgIHJlc2V0T25GaW5pc2g6IGZhbHNlLFxuICAgIH07XG5cbiAgICAvLyBFbnN1cmUgdGhhdCAndGhpcycgaW5zaWRlIHRoZSBfb25XaW5kb3dSZXNpemUgZXZlbnQgaGFuZGxlciByZWZlcnMgdG8gPGJvbHQtbmF2LWxpbms+XG4gICAgLy8gZXZlbiBpZiB0aGUgaGFuZGxlciBpcyBhdHRhY2hlZCB0byBhbm90aGVyIGVsZW1lbnQgKHdpbmRvdyBpbiB0aGlzIGNhc2UpXG4gICAgdGhpcy5fb25XaW5kb3dSZXNpemUgPSB0aGlzLl9vbldpbmRvd1Jlc2l6ZS5iaW5kKHRoaXMpO1xuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICBnZXQgcmVuZGVyUm9vdCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldCBleHBhbmRlZEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2V4cGFuZGVkSGVpZ2h0Jyk7XG4gIH1cblxuICAvKipcbiAgICogUHJvcGVydGllcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBhdHRyaWJ1dGVzIHNob3VsZCBtaXJyb3Igb25lIGFub3RoZXIuXG4gICAqIFRvIHRoaXMgZWZmZWN0LCB0aGUgcHJvcGVydHkgc2V0dGVyIGZvciBgZXhwYW5kZWRgIGhhbmRsZXMgdHJ1dGh5L2ZhbHN5XG4gICAqIHZhbHVlcyBhbmQgcmVmbGVjdHMgdGhvc2UgdG8gdGhlIHN0YXRlIG9mIHRoZSBhdHRyaWJ1dGUuIEl04oCZcyBpbXBvcnRhbnRcbiAgICogdG8gbm90ZSB0aGF0IHRoZXJlIGFyZSBubyBzaWRlIGVmZmVjdHMgdGFraW5nIHBsYWNlIGluIHRoZSBwcm9wZXJ0eVxuICAgKiBzZXR0ZXIuIEZvciBleGFtcGxlLCB0aGUgc2V0dGVyIGRvZXMgbm90IHNldCBgYXJpYS1leHBhbmRlZGAuIEluc3RlYWQsXG4gICAqIHRoYXQgd29yayBoYXBwZW5zIGluIHRoZSBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYC4gQXMgYSBnZW5lcmFsIHJ1bGUsXG4gICAqIG1ha2UgcHJvcGVydHkgc2V0dGVycyB2ZXJ5IGR1bWIsIGFuZCBpZiBzZXR0aW5nIGEgcHJvcGVydHkgb3IgYXR0cmlidXRlXG4gICAqIHNob3VsZCBjYXVzZSBhIHNpZGUgZWZmZWN0IChsaWtlIHNldHRpbmcgYSBjb3JyZXNwb25kaW5nIEFSSUEgYXR0cmlidXRlKVxuICAgKiBkbyB0aGF0IHdvcmsgaW4gdGhlIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgLiBUaGlzIHdpbGwgYXZvaWQgaGF2aW5nIHRvXG4gICAqIG1hbmFnZSBjb21wbGV4IGF0dHJpYnV0ZS9wcm9wZXJ0eSByZWVudHJhbmN5IHNjZW5hcmlvcy5cbiAgICovXG4gIHNldCBleHBhbmRlZEhlaWdodCh2YWx1ZSkge1xuICAgIC8vIFByb3BlcnRpZXMgY2FuIGJlIHNldCB0byBhbGwga2luZHMgb2Ygc3RyaW5nIHZhbHVlcy4gVGhpcyBtYWtlcyBzdXJlXG4gICAgLy8gaXTigJlzIGNvbnZlcnRlZCB0byBhIHByb3BlciBib29sZWFuIHZhbHVlIHVzaW5nIEphdmFTY3JpcHTigJlzIHRydXRoaW5lc3NcbiAgICAvLyAmIGZhbHNpbmVzcyBwcmluY2lwbGVzLlxuICAgIC8vIHZhbHVlID0gQm9vbGVhbih2YWx1ZSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnZXhwYW5kZWRIZWlnaHQnLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdleHBhbmRlZEhlaWdodCcpO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBDdXN0b21FdmVudCgndmlkZW9FeHBhbmRlZEhlaWdodFNldCcsIHtcbiAgICAgICAgZGV0YWlsOiB7IGV4cGFuZGVkSGVpZ2h0OiB0aGlzLmV4cGFuZGVkSGVpZ2h0IH0sXG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgLy8gQ2FsbGVkIHRvIGNoZWNrIHdoZXRoZXIgb3Igbm90IHRoZSBjb21wb25lbnQgc2hvdWxkIGNhbGxcbiAgLy8gdXBkYXRlZCgpLCBtdWNoIGxpa2UgUmVhY3QncyBzaG91bGRDb21wb25lbnRVcGRhdGUoKS5cbiAgLy8gdXBkYXRpbmcocHJvcHMsIHN0YXRlKSB7XG4gIC8vICAgY29uc29sZS5sb2cocHJvcHMpO1xuICAvLyAgIGNvbnNvbGUubG9nKHN0YXRlKTtcbiAgLy8gfVxuXG4gIF9zZXRNZXRhVGl0bGUodGl0bGUpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5zaG93TWV0YSAmJiB0aGlzLnByb3BzLnNob3dNZXRhVGl0bGUpIHtcbiAgICAgIHRoaXMucXVlcnlTZWxlY3RvcihgJHtib2x0Lm5hbWVzcGFjZX0tdmlkZW8tbWV0YWApLnNldEF0dHJpYnV0ZShcbiAgICAgICAgJ3RpdGxlJyxcbiAgICAgICAgdGl0bGUsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIF9zZXRNZXRhRHVyYXRpb24oc2Vjb25kcykge1xuICAgIGlmICh0aGlzLnByb3BzLnNob3dNZXRhKSB7XG4gICAgICBjb25zdCBkdXJhdGlvbkZvcm1hdHRlZCA9IEJvbHRWaWRlby5fZm9ybWF0RHVyYXRpb24oc2Vjb25kcyk7XG4gICAgICB0aGlzLnF1ZXJ5U2VsZWN0b3IoYCR7Ym9sdC5uYW1lc3BhY2V9LXZpZGVvLW1ldGFgKS5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICdkdXJhdGlvbicsXG4gICAgICAgIGR1cmF0aW9uRm9ybWF0dGVkLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgX2Zvcm1hdER1cmF0aW9uKHNlY29uZHMpIHtcbiAgICBjb25zdCBtbSA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDYwKSB8fCAwO1xuICAgIGNvbnN0IHNzID0gKCcwJyArIE1hdGguZmxvb3Ioc2Vjb25kcyAlIDYwKSkuc2xpY2UoLTIpO1xuXG4gICAgcmV0dXJuIG1tICsgJzonICsgc3M7XG4gIH1cblxuICBfc2V0VmlkZW9EaW1lbnNpb25zKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnNyY1dpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5zcmNIZWlnaHQgPSBoZWlnaHQ7XG4gIH1cblxuICBzdGF0aWMgaGFuZGxlUGxheWVyUmVhZHkoY29udGV4dCkge1xuICAgIGNvbnN0IHBsYXllciA9IHRoaXM7XG4gICAgY29uc3QgZWxlbSA9IGNvbnRleHQ7XG5cbiAgICBlbGVtLnNldFBsYXllcihwbGF5ZXIpO1xuXG4gICAgLy8gSWYgdGhlIG9wdGlvbiB0byBzaG93IGNvbnRyb2xzIGlzIHNldCB0byBmYWxzZSAobWVhbmluZywgbm8gY29udHJvbHMgd2lsbCBiZSBzaG93biksIG1ha2Ugc3VyZSB0aGUgdmlkZW8gaXMgYWxzbyBtdXRlZC5cbiAgICBpZiAoZWxlbS5jb250cm9scyA9PT0gZmFsc2UpIHtcbiAgICAgIGVsZW0ucGxheWVyLm11dGVkKHRydWUpO1xuICAgIH1cblxuICAgIHBsYXllci5vbignbG9hZGVkbWV0YWRhdGEnLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gcGxheWVyLm1lZGlhaW5mby5kdXJhdGlvbjtcbiAgICAgIGNvbnN0IHRpdGxlID0gcGxheWVyLm1lZGlhaW5mby5uYW1lO1xuICAgICAgY29uc3Qgd2lkdGggPSBwbGF5ZXIubWVkaWFpbmZvLnNvdXJjZXNbMV0ud2lkdGg7XG4gICAgICBjb25zdCBoZWlnaHQgPSBwbGF5ZXIubWVkaWFpbmZvLnNvdXJjZXNbMV0uaGVpZ2h0O1xuXG4gICAgICBlbGVtLl9zZXRNZXRhVGl0bGUodGl0bGUpO1xuICAgICAgZWxlbS5fc2V0TWV0YUR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgIGVsZW0uX3NldFZpZGVvRGltZW5zaW9ucyh3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgaWYgKHRoaXMuZWFybHlUb2dnbGUpIHtcbiAgICAgICAgdGhpcy5lYXJseVRvZ2dsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmVhcmx5UGxheSkge1xuICAgICAgICB0aGlzLmVhcmx5UGxheSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5lYXJseVBhdXNlKSB7XG4gICAgICAgIHRoaXMuZWFybHlQYXVzZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBwbGF5ZXIub24oJ3BsYXknLCBmdW5jdGlvbigpIHtcbiAgICAgIGVsZW0ub25QbGF5KHBsYXllcik7XG4gICAgfSk7XG5cbiAgICBwbGF5ZXIub24oJ3BhdXNlJywgZnVuY3Rpb24oKSB7XG4gICAgICBlbGVtLm9uUGF1c2UocGxheWVyKTtcbiAgICB9KTtcblxuICAgIHBsYXllci5vbignc2Vla2VkJywgZnVuY3Rpb24oKSB7XG4gICAgICBlbGVtLm9uU2Vla2VkKHBsYXllcik7XG4gICAgfSk7XG5cbiAgICBwbGF5ZXIub24oJ3RpbWV1cGRhdGUnLCBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGVsZW0ub25QbGF5KHBsYXllcik7XG4gICAgfSk7XG5cbiAgICBwbGF5ZXIub24oJ2R1cmF0aW9uY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICBlbGVtLm9uRHVyYXRpb25DaGFuZ2UocGxheWVyKTtcbiAgICB9KTtcblxuICAgIHBsYXllci5vbignZW5kZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgIGVsZW0ub25FbmRlZChwbGF5ZXIpO1xuICAgIH0pO1xuXG4gICAgLy8gdGhpcy5jb250ZXh0bWVudSh7IGRpc2FibGVkOiB0cnVlIH0pO1xuICB9XG5cbiAgc3RhdGljIGFwcGVuZFNjcmlwdChzKSB7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRTY3JpcHRVcmwoYWNjb3VudElkLCBwbGF5ZXJJZCkge1xuICAgIHJldHVybiBgLy9wbGF5ZXJzLmJyaWdodGNvdmUubmV0LyR7YWNjb3VudElkfS8ke3BsYXllcklkfV9kZWZhdWx0L2luZGV4Lm1pbi5qc2A7XG4gIH1cblxuICBzdGF0aWMgZ2V0Q3VycmVudFRpbWVNcyhwbGF5ZXIpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChwbGF5ZXIuY3VycmVudFRpbWUoKSAqIDEwMDApO1xuICB9XG5cbiAgc3RhdGljIGdldER1cmF0aW9uTXMocGxheWVyKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQocGxheWVyLmR1cmF0aW9uKCkgKiAxMDAwKTtcbiAgfVxuXG4gIC8vIHN0YXRpYyBpc0JhY2tncm91bmRWaWRlbygpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5wcm9wcy5pc0JhY2tncm91bmRWaWRlbztcbiAgLy8gfVxuXG4gIGhhbmRsZUNsb3NlKCkge1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfVxuXG4gIGNvbm5lY3RpbmcoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIC8vIElEcyBjYW4ndCBzdGFydCB3aXRoIG51bWJlcnMgc28gYWRkaW5nIHRoZSBcInZcIiBwcmVmaXggdG8gcHJldmVudCBKUyBlcnJvcnNcbiAgICAgIGlkOiBgdiR7dGhpcy5wcm9wcy52aWRlb0lkfS0ke3RoaXMucHJvcHMuYWNjb3VudElkfS0ke2luZGV4fWAsXG4gICAgICAvLyBlcnJvcnM6IEJvbHRWaWRlby5nbG9iYWxFcnJvcnMgIT09IHVuZGVmaW5lZCAgPyBbXS5jb25jYXQoQm9sdFZpZGVvLmdsb2JhbEVycm9ycykgOiBbXSxcbiAgICAgIGlzUGxheWluZzogJ3BhdXNlZCcsXG4gICAgICBpc0ZpbmlzaGVkOiBmYWxzZSxcbiAgICAgIHByb2dyZXNzOiAwLFxuICAgIH07XG5cbiAgICBpZiAodGhpcy5wcm9wcy5pc0JhY2tncm91bmRWaWRlbykge1xuICAgICAgdGhpcy5fY2FsY3VsYXRlSWRlYWxWaWRlb1NpemUoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRQcm9wcyA9IHRoaXMuZGVmYXVsdFByb3BzO1xuICAgICAgZm9yIChjb25zdCBwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoQm9sdFZpZGVvLmdsb2JhbEVycm9ycyAhPT0gdW5kZWZpbmVkICYmIEJvbHRWaWRlby5nbG9iYWxFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnYWRkaW5nIGRlZmF1bHQgZXJyb3JzJyk7XG4gICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnN0YXRlLmVycm9ycyk7XG4gICAgICB0aGlzLnN0YXRlLmVycm9ycyA9IFtdLmNvbmNhdChCb2x0VmlkZW8uZ2xvYmFsRXJyb3JzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZS5lcnJvcnMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnN0YXRlLmVycm9ycyk7XG4gICAgICAvLyBjb25zb2xlLmxvZygnZXJyb3IgbGVuZ3RoJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gb25seSBldmVyIGFwcGVuZCBzY3JpcHQgb25jZVxuICAgIGlmICghQm9sdFZpZGVvLnBsYXllcnMpIHtcbiAgICAgIEJvbHRWaWRlby5wbGF5ZXJzID0gW107XG5cbiAgICAgIGNvbnN0IHMgPSB0aGlzLmNyZWF0ZVNjcmlwdCgpO1xuXG4gICAgICBzLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgQm9sdFZpZGVvLnBsYXllcnMuZm9yRWFjaChmdW5jdGlvbihwbGF5ZXIpIHtcbiAgICAgICAgICBwbGF5ZXIuaW5pdFZpZGVvSlMocGxheWVyLnN0YXRlLmlkKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBoYW5kbGUgc2NyaXB0IG5vdCBsb2FkaW5nXG4gICAgICBzLm9uZXJyb3IgPSBlcnIgPT4ge1xuICAgICAgICBjb25zdCB1cmlFcnIgPSB7XG4gICAgICAgICAgY29kZTogJycsXG4gICAgICAgICAgbWVzc2FnZTogYFRoZSBzY3JpcHQgJHtlcnIudGFyZ2V0LnNyY30gaXMgbm90IGFjY2Vzc2libGUuYCxcbiAgICAgICAgfTtcblxuICAgICAgICBCb2x0VmlkZW8uZ2xvYmFsRXJyb3JzLnB1c2godXJpRXJyKTtcblxuICAgICAgICB0aGlzLnByb3BzLm9uRXJyb3IodXJpRXJyKTtcbiAgICAgIH07XG5cbiAgICAgIEJvbHRWaWRlby5hcHBlbmRTY3JpcHQocyk7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0KCk7XG5cbiAgICAvLyBJZiBvbkluaXQgZXZlbnQgZXhpc3RzIG9uIGVsZW1lbnQsIHJ1biB0aGF0IGluc3RlYWQgb2YgYXV0byBpbml0aWFsaXppbmdcbiAgICBpZiAodGhpcy5wcm9wcy5vbkluaXQpIHtcbiAgICAgIGlmICh3aW5kb3dbdGhpcy5wcm9wcy5vbkluaXRdKSB7XG4gICAgICAgIHdpbmRvd1t0aGlzLnByb3BzLm9uSW5pdF0odGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgb3VyIHZpZGVvIGNhbiBleHBhbmQvY29sbGFwc2Ugd2UgYWRkIHRoZSBjb2xsYXBzZSBsaXN0ZW5lciBhbmQgXCJjbG9zZSBvbiBlc2NhcGVcIiBiZWhhdmlvclxuICAgIGlmICh0aGlzLnByb3BzLmlzQmFja2dyb3VuZFZpZGVvKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fb25XaW5kb3dSZXNpemUpO1xuICAgICAgTW91c2V0cmFwLmJpbmQoJ2VzYycsIHRoaXMuaGFuZGxlQ2xvc2UsICdrZXl1cCcpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmNvbGxhcHNlT25DbGlja0F3YXkpO1xuICAgIH1cbiAgfVxuXG4gIF9vbldpbmRvd1Jlc2l6ZShldmVudCkge1xuICAgIHRoaXMuX2NhbGN1bGF0ZUlkZWFsVmlkZW9TaXplKCk7XG4gIH1cblxuICAvLyBJZiB3ZSBjbGljayBvdXRzaWRlIHRoZSB2aWRlbyB3cmFwcGVyIGRpdiBjb2xsYXBzZSB0aGUgdmlkZW9cbiAgY29sbGFwc2VPbkNsaWNrQXdheShldmVudCkge1xuICAgIGNvbnN0IHZpZGVvV3JhcHBlciA9IHRoaXMucXVlcnlTZWxlY3RvcignLmMtYm9sdC12aWRlby0tYmFja2dyb3VuZCcpO1xuICAgIGlmICghdmlkZW9XcmFwcGVyLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIC8vIEB0b2RvOiBkZWJ1ZyB3aHkgdmlkZW9zIGRvbid0IGF1dG9wbGF5IHdoZW4gdGhpcyBpcyBlbmFibGVkXG4gICAgICAvLyB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gc2hvdWxkVXBkYXRlKHByb3BzLCBzdGF0ZSkge1xuICAvLyAgIHJldHVybiB0cnVlO1xuICAvLyB9XG5cbiAgLy8gQ2FsbGVkIHdoZW4gcHJvcHMgaGF2ZSBiZWVuIHNldCByZWdhcmRsZXNzIG9mIGlmIHRoZXkndmUgY2hhbmdlZC5cbiAgLy8gdXBkYXRpbmcocHJvcHMpIHsgfVxuXG4gIC8qKlxuICAgKiBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCBwcm9jZXNzZXMgY2hhbmdlcyB0byB0aGUgYGV4cGFuZGVkYCBhdHRyaWJ1dGUuXG4gICAqL1xuICAvLyBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0cmlidXRlTmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gIC8vICAgY29uc29sZS5sb2coYXR0cmlidXRlTmFtZSk7XG4gIC8vICAgLy8gYGV4cGFuZGVkYCBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGl0IGlzIGVpdGhlciBzZXQgb3Igbm90IHNldC4gVGhlXG4gIC8vICAgLy8gYWN0dWFsIHZhbHVlIGlzIGlycmVsZXZhbnQuXG4gIC8vICAgLy8gY29uc3QgdmFsdWUgPSB0aGlzLmhhc0F0dHJpYnV0ZSgnZXhwYW5kZWQnKTtcbiAgLy8gICAvLyB0aGlzLl9zaGFkb3dCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgdmFsdWUpO1xuICAvLyB9XG5cbiAgZGlzY29ubmVjdGluZygpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5pc0JhY2tncm91bmRWaWRlbykge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29wdGltaXplZFJlc2l6ZScsIHRoaXMuX29uV2luZG93UmVzaXplKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wbGF5ZXIpIHtcbiAgICAgIHRoaXMucGxheWVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cblxuICBvbkVycm9yKHBsYXllcikge1xuICAgIHRoaXMucHJvcHMub25FcnJvcihwbGF5ZXIuZXJyb3IoKSk7XG4gIH1cblxuICBvblBsYXkocGxheWVyKSB7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdpcy1wbGF5aW5nJyk7XG4gICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdpcy1maW5pc2hlZCcpO1xuICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnaXMtcGF1c2VkJyk7XG5cbiAgICAvLyBAVE9ETzogaW1wbGVtZW50IGludGVybmFsIHNldFN0YXRlIG1ldGhvZFxuICAgIC8vIGVsZW0uc2V0U3RhdGUoe1xuICAgIC8vICAgaXNQbGF5aW5nOiB0cnVlLFxuICAgIC8vICAgcHJvZ3Jlc3M6IEJvbHRWaWRlby5nZXRDdXJyZW50VGltZU1zKHBsYXllciksXG4gICAgLy8gICBpc0ZpbmlzaGVkOiBmYWxzZVxuICAgIC8vIH0pO1xuXG4gICAgLy8gRGlzcGF0Y2ggYW4gZXZlbnQgdGhhdCBzaWduYWxzIGEgcmVxdWVzdCB0byBleHBhbmQgdG8gdGhlXG4gICAgLy8gYDxob3d0by1hY2NvcmRpb24+YCBlbGVtZW50LlxuICAgIHRoaXMuc3RhdGUuaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICB0aGlzLnN0YXRlLnByb2dyZXNzID0gQm9sdFZpZGVvLmdldEN1cnJlbnRUaW1lTXMocGxheWVyKTtcbiAgICB0aGlzLnN0YXRlLmlzRmluaXNoZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBDdXN0b21FdmVudCgncGxheWluZycsIHtcbiAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgaXNCYWNrZ3JvdW5kVmlkZW86IHRoaXMucHJvcHMuaXNCYWNrZ3JvdW5kVmlkZW8sXG4gICAgICAgIH0sXG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgb25QYXVzZShwbGF5ZXIpIHtcbiAgICBjb25zdCBwcm9ncmVzcyA9IEJvbHRWaWRlby5nZXRDdXJyZW50VGltZU1zKHBsYXllcik7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2lzLXBhdXNlZCcpO1xuICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnaXMtcGxheWluZycpO1xuXG4gICAgLy8gQFRPRE86IGltcGxlbWVudCBpbnRlcm5hbCBzZXRTdGF0ZSBtZXRob2RcbiAgICAvLyB0aGlzLnNldFN0YXRlKHtcbiAgICAvLyAgIGlzUGxheWluZzogZmFsc2UsXG4gICAgLy8gICBwcm9ncmVzc1xuICAgIC8vIH0pO1xuXG4gICAgdGhpcy5zdGF0ZS5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlLnByb2dyZXNzID0gcHJvZ3Jlc3M7XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICBuZXcgQ3VzdG9tRXZlbnQoJ3BhdXNlJywge1xuICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICBpc0JhY2tncm91bmRWaWRlbzogdGhpcy5wcm9wcy5pc0JhY2tncm91bmRWaWRlbyxcbiAgICAgICAgfSxcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBvblNlZWtlZChwbGF5ZXIpIHtcbiAgICBjb25zdCBwcm9ncmVzcyA9IEJvbHRWaWRlby5nZXRDdXJyZW50VGltZU1zKHBsYXllcik7XG5cbiAgICAvLyBAVE9ETzogaW1wbGVtZW50IGludGVybmFsIHNldFN0YXRlIG1ldGhvZFxuICAgIC8vIHRoaXMuc2V0U3RhdGUoe1xuICAgIC8vICAgcHJvZ3Jlc3M6IEJvbHRWaWRlby5nZXRDdXJyZW50VGltZU1zKHBsYXllciksXG4gICAgLy8gICBpc0ZpbmlzaGVkOiBmYWxzZVxuICAgIC8vIH0pO1xuICAgIHRoaXMuc3RhdGUuaXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhdGUucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgfVxuXG4gIG9uRHVyYXRpb25DaGFuZ2UocGxheWVyKSB7XG4gICAgY29uc3QgZHVyYXRpb24gPSBCb2x0VmlkZW8uZ2V0RHVyYXRpb25NcyhwbGF5ZXIpO1xuXG4gICAgLy8gQFRPRE86IGltcGxlbWVudCBpbnRlcm5hbCBzZXRTdGF0ZSBtZXRob2RcbiAgICAvLyB0aGlzLnNldFN0YXRlKHsgZHVyYXRpb246IEJvbHRWaWRlby5nZXREdXJhdGlvbk1zKHBsYXllcikgfSk7XG5cbiAgICB0aGlzLnN0YXRlLmR1cmF0aW9uID0gZHVyYXRpb247XG4gIH1cblxuICBvbkVuZGVkKCkge1xuICAgIC8vIGNhbGxpbmcgc3luY3Jvbm91c2x5IGhlcmUgaW50ZWZlcmVzIHdpdGggcGxheWVyIGFuZCBjYXVzZXMgZXJyb3JzIHRvIGJlIHRocm93blxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnN0YXRlLmlzRmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2lzLWZpbmlzaGVkJyk7XG4gICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLXBhdXNlZCcpO1xuXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBDdXN0b21FdmVudCgnZW5kZWQnLCB7XG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpc0JhY2tncm91bmRWaWRlbzogdGhpcy5wcm9wcy5pc0JhY2tncm91bmRWaWRlbyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICAgIC8vIHRoaXMuc2V0U3RhdGUoeyBpc0ZpbmlzaGVkOiB0cnVlIH0pO1xuICAgIH0sIDApO1xuICB9XG5cbiAgX2NhbGN1bGF0ZUlkZWFsVmlkZW9TaXplKCkge1xuICAgIHRoaXMuZXhwYW5kZWRIZWlnaHQgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgfVxuXG4gIHNldFBsYXllcihwbGF5ZXIpIHtcbiAgICB0aGlzLnBsYXllciA9IHBsYXllcjtcbiAgfVxuXG4gIGNyZWF0ZVNjcmlwdCgpIHtcbiAgICBjb25zdCBzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cbiAgICBzLnNyYyA9IEJvbHRWaWRlby5nZXRTY3JpcHRVcmwodGhpcy5wcm9wcy5hY2NvdW50SWQsIHRoaXMucHJvcHMucGxheWVySWQpO1xuICAgIHMuYXN5bmMgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHM7XG4gIH1cblxuICBpbml0VmlkZW9KUyhpZCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgYmVmb3JlTmV4dFJlbmRlcih0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IHBsYXllciA9IHZpZGVvanMoaWQpO1xuICAgICAgY29uc3QgaGFuZGxlciA9IEJvbHRWaWRlby5oYW5kbGVQbGF5ZXJSZWFkeS5iaW5kKHBsYXllciwgc2VsZik7XG4gICAgICBwbGF5ZXIucmVhZHkoaGFuZGxlcik7XG4gICAgfSk7XG4gIH1cblxuICBpbml0VmlkZW8oaWQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIGJlZm9yZU5leHRSZW5kZXIodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICBiYyhzZWxmLnF1ZXJ5U2VsZWN0b3IoYCMke2lkfWApLCB7XG4gICAgICAgIGNvbnRyb2xCYXI6IHtcbiAgICAgICAgICBmdWxsc2NyZWVuVG9nZ2xlOiAhc2VsZi5wcm9wcy5oaWRlRnVsbFNjcmVlbkJ1dHRvbixcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgc2VsZi5pbml0VmlkZW9KUyhpZCk7XG4gICAgfSk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgYmVmb3JlTmV4dFJlbmRlcih0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh3aW5kb3cuYmMgJiYgd2luZG93LnZpZGVvanMpIHtcbiAgICAgICAgc2VsZi5pbml0VmlkZW8oc2VsZi5zdGF0ZS5pZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBCb2x0VmlkZW8ucGxheWVycy5wdXNoKHNlbGYpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcGxheSgpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXIpIHtcbiAgICAgIHRoaXMucGxheWVyLnBsYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lYXJseVBsYXkgPSB0cnVlO1xuXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgIG5ldyBDdXN0b21FdmVudCgncGxheWluZycsIHtcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlzQmFja2dyb3VuZFZpZGVvOiB0aGlzLnByb3BzLmlzQmFja2dyb3VuZFZpZGVvLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHRoaXMucGF1c2UoKTtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBDdXN0b21FdmVudCgnY2xvc2UnLCB7XG4gICAgICAgIGRldGFpbDoge1xuICAgICAgICAgIGlzQmFja2dyb3VuZFZpZGVvOiB0aGlzLnByb3BzLmlzQmFja2dyb3VuZFZpZGVvLFxuICAgICAgICB9LFxuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIHRvZ2dsZSgpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXIpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmlzUGxheWluZyA9PT0gZmFsc2UgfHwgdGhpcy5zdGF0ZS5pc1BsYXlpbmcgPT09ICdwYXVzZWQnKSB7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVhcmx5VG9nZ2xlID0gdHJ1ZTtcblxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KFxuICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoJ3BsYXlpbmcnLCB7XG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpc0JhY2tncm91bmRWaWRlbzogdGhpcy5wcm9wcy5pc0JhY2tncm91bmRWaWRlbyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwYXVzZSgpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXIpIHtcbiAgICAgIHRoaXMucGxheWVyLnBhdXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWFybHlQYXVzZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKHsgc3RhdGUsIHByb3BzIH0pIHtcbiAgICAvLyBjb25zb2xlLmxvZygncmVuZGVyIGNhbGxiYWNrJyk7XG4gICAgLy8gZGF0YS1lbWFpbC1zdWJqZWN0PVwiUGVnYSAtIEludGVsbGlnZW50IFZpcnR1YWwgQXNzaXN0YW50IGZvciBFbWFpbFwiXG4gICAgLy8gZGF0YS1lbWFpbC1ib2R5PVwiQ2hlY2sgb3V0IHRoaXMgdmlkZW8gZnJvbSBQZWdhXCJcbiAgICAvLyBkYXRhLWVtYWlsLXZpZGVvdXJsPVwiaHR0cHM6Ly9sb2NhbC5kOC5wZWdhLmNvbS9pbnNpZ2h0cy9yZXNvdXJjZXMvaW50ZWxsaWdlbnQtdmlydHVhbC1hc3Npc3RhbnQtZW1haWxcIlxuXG4gICAgLy8gY29uc3QgcGxheUljb25FbW9qaSA9ICgpID0+IChcbiAgICAvLyAgIDxzcGFuIHJvbGU9XCJpbWdcIiBhcmlhLWxhYmVsPVwicGxheS12aWRlb1wiPlxuICAgIC8vICAgICDilrbvuI9cbiAgICAvLyAgIDwvc3Bhbj5cbiAgICAvLyApO1xuICAgIC8qIGVzbGludCBqc3gtYTExeS9tZWRpYS1oYXMtY2FwdGlvbjogXCJvZmZcIiAqL1xuICAgIC8vIEFkZGVkIGEgd3JhcHBpbmcgZGl2IGFzIGJyaWdodGNvdmUgYWRkcyBzaWJsaW5ncyB0byB0aGUgdmlkZW8gdGFnXG5cbiAgICAvLyBMb29wIHRocm91Z2ggYW55IGV4dHJhICh1bmtub3duKSBkYXRhIGF0dHJpYnV0ZXMgb24gdGhlIG1haW4gZWxlbWVudDsgY29weSBvdmVyIHRvIHRoZSA8dmlkZW8+IHRhZyBiZWluZyByZW5kZXJlZFxuICAgIGZ1bmN0aW9uIGRhdGFzZXRUb09iamVjdChlbGVtKSB7XG4gICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgW10uZm9yRWFjaC5jYWxsKGVsZW0uYXR0cmlidXRlcywgZnVuY3Rpb24oYXR0cikge1xuICAgICAgICBpZiAoL15kYXRhLS8udGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgZGF0YVtkYXNoZXJpemUoYXR0ci5uYW1lKV0gPSBhdHRyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGFBdHRyaWJ1dGVzID0gZGF0YXNldFRvT2JqZWN0KHRoaXMpO1xuXG4gICAgbGV0IGNsb3NlQnV0dG9uVGV4dCA9IG51bGw7XG4gICAgaWYgKHRoaXMucHJvcHMuY2xvc2VCdXR0b25UZXh0KSB7XG4gICAgICBjbG9zZUJ1dHRvblRleHQgPSB0aGlzLnByb3BzLmNsb3NlQnV0dG9uVGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvc2VCdXR0b25UZXh0ID0gJ0Nsb3NlJztcbiAgICB9XG5cbiAgICBjb25zdCBjbGFzc2VzID0gY3NzKFxuICAgICAgYGMtJHtib2x0Lm5hbWVzcGFjZX0tdmlkZW9gLFxuICAgICAgdGhpcy5wcm9wcy5jb250cm9scyA9PT0gZmFsc2VcbiAgICAgICAgPyBgYy0ke2JvbHQubmFtZXNwYWNlfS12aWRlby0taGlkZS1jb250cm9sc2BcbiAgICAgICAgOiAnJyxcbiAgICAgIHRoaXMucHJvcHMuaXNCYWNrZ3JvdW5kVmlkZW9cbiAgICAgICAgPyBgYy0ke2JvbHQubmFtZXNwYWNlfS12aWRlby0tYmFja2dyb3VuZGBcbiAgICAgICAgOiAnJyxcbiAgICApO1xuXG4gICAgY29uc3QgdmlkZW9NZXRhVGFnID0gYCR7Ym9sdC5uYW1lc3BhY2V9LXZpZGVvLW1ldGFgO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxzcGFuIGNsYXNzTmFtZT17Y2xhc3Nlc30+XG4gICAgICAgIDx2aWRlb1xuICAgICAgICAgIHsuLi5kYXRhQXR0cmlidXRlc31cbiAgICAgICAgICBpZD17dGhpcy5zdGF0ZS5pZH1cbiAgICAgICAgICB7Li4uKHRoaXMucHJvcHMucG9zdGVyID8geyBwb3N0ZXI6IHRoaXMucHJvcHMucG9zdGVyLnVyaSB9IDoge30pfVxuICAgICAgICAgIGRhdGEtZW1iZWQ9XCJkZWZhdWx0XCJcbiAgICAgICAgICBkYXRhLXZpZGVvLWlkPXt0aGlzLnByb3BzLnZpZGVvSWR9XG4gICAgICAgICAgcHJlbG9hZD1cIm5vbmVcIlxuICAgICAgICAgIGRhdGEtYWNjb3VudD17dGhpcy5wcm9wcy5hY2NvdW50SWR9XG4gICAgICAgICAgZGF0YS1wbGF5ZXI9e3RoaXMucHJvcHMucGxheWVySWR9XG4gICAgICAgICAgLy8gcGxheUljb249e3BsYXlJY29uRW1vamkoKX1cbiAgICAgICAgICAvLyBmb2xsb3dpbmcgJ2F1dG9wbGF5JyBjYW4gbm90IGV4cGVjdGVkIHRvIGFsd2F5cyB3b3JrIG9uIHdlYlxuICAgICAgICAgIC8vIHNlZTogaHR0cHM6Ly9kb2NzLmJyaWdodGNvdmUuY29tL2VuL3BsYXllci9icmlnaHRjb3ZlLXBsYXllci9ndWlkZXMvaW4tcGFnZS1lbWJlZC1wbGF5ZXItaW1wbGVtZW50YXRpb24uaHRtbFxuICAgICAgICAgIGF1dG9QbGF5PXt0aGlzLnByb3BzLmF1dG9wbGF5fVxuICAgICAgICAgIGRhdGEtYXBwbGljYXRpb24taWRcbiAgICAgICAgICBsb29wPXt0aGlzLnByb3BzLmxvb3B9XG4gICAgICAgICAgY2xhc3NOYW1lPVwidmlkZW8tanNcIlxuICAgICAgICAgIGNvbnRyb2xzPXt0aGlzLnByb3BzLmNvbnRyb2xzID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZX1cbiAgICAgICAgLz5cbiAgICAgICAge3RoaXMucHJvcHMuc2hvd01ldGEgJiYgaCh2aWRlb01ldGFUYWcpfVxuICAgICAgICB7dGhpcy5wcm9wcy5pc0JhY2tncm91bmRWaWRlbyAmJiAoXG4gICAgICAgICAgPGFcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y3NzKFxuICAgICAgICAgICAgICBgYy0ke2JvbHQubmFtZXNwYWNlfS12aWRlb19fY2xvc2UtYnV0dG9uYCxcbiAgICAgICAgICAgICAgYGMtJHtib2x0Lm5hbWVzcGFjZX0tdmlkZW9fX2Nsb3NlLWJ1dHRvbi0taWNvbi10by10ZXh0YCxcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICBocmVmPVwiamF2YXNjcmlwdDpcIlxuICAgICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVDbG9zZX0+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2BjLSR7Ym9sdC5uYW1lc3BhY2V9LXZpZGVvX19jbG9zZS1idXR0b24taWNvbmB9PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYy1ib2x0LWJ1dHRvbiBjLWJvbHQtYnV0dG9uLS14c21hbGwgYy1ib2x0LWJ1dHRvbi0tc2Vjb25kYXJ5IGMtYm9sdC1idXR0b24tLXJvdW5kZWQgYy1ib2x0LWJ1dHRvbi0taWNvbi1vbmx5XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjLWJvbHQtYnV0dG9uX19pY29uXCI+XG4gICAgICAgICAgICAgICAgICA8Ym9sdC1pY29uIG5hbWU9XCJjbG9zZVwiIHNpemU9XCJzbWFsbFwiIC8+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17YGMtJHtib2x0Lm5hbWVzcGFjZX0tdmlkZW9fX2Nsb3NlLWJ1dHRvbi10ZXh0YH0+XG4gICAgICAgICAgICAgIHtjbG9zZUJ1dHRvblRleHR9XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgPC9hPlxuICAgICAgICApfVxuICAgICAgPC9zcGFuPlxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQm9sdFZpZGVvO1xuXG5leHBvcnQgeyBCb2x0VmlkZW8sIEJvbHRWaWRlb01ldGEgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@bolt/components-video/src/video.standalone.js\n");

/***/ }),

/***/ "./node_modules/dasherize/index.js":
/*!*****************************************!*\
  !*** ./node_modules/dasherize/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar isArray = Array.isArray || function (obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\nvar isDate = function isDate(obj) {\n  return Object.prototype.toString.call(obj) === '[object Date]';\n};\n\nvar isRegex = function isRegex(obj) {\n  return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\nvar has = Object.prototype.hasOwnProperty;\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      keys.push(key);\n    }\n  }\n\n  return keys;\n};\n\nfunction dashCase(str) {\n  return str.replace(/[A-Z](?:(?=[^A-Z])|[A-Z]*(?=[A-Z][^A-Z]|$))/g, function (s, i) {\n    return (i > 0 ? '-' : '') + s.toLowerCase();\n  });\n}\n\nfunction map(xs, f) {\n  if (xs.map) {\n    return xs.map(f);\n  }\n\n  var res = [];\n\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n\n  return res;\n}\n\nfunction reduce(xs, f, acc) {\n  if (xs.reduce) {\n    return xs.reduce(f, acc);\n  }\n\n  for (var i = 0; i < xs.length; i++) {\n    acc = f(acc, xs[i], i);\n  }\n\n  return acc;\n}\n\nfunction walk(obj) {\n  if (!obj || _typeof(obj) !== 'object') {\n    return obj;\n  }\n\n  if (isDate(obj) || isRegex(obj)) {\n    return obj;\n  }\n\n  if (isArray(obj)) {\n    return map(obj, walk);\n  }\n\n  return reduce(objectKeys(obj), function (acc, key) {\n    var camel = dashCase(key);\n    acc[camel] = walk(obj[key]);\n    return acc;\n  }, {});\n}\n\nmodule.exports = function (obj) {\n  if (typeof obj === 'string') {\n    return dashCase(obj);\n  }\n\n  return walk(obj);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGFzaGVyaXplL2luZGV4LmpzP2Q5YzQiXSwibmFtZXMiOlsiaXNBcnJheSIsIkFycmF5Iiwib2JqIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiaXNEYXRlIiwiaXNSZWdleCIsImhhcyIsImhhc093blByb3BlcnR5Iiwib2JqZWN0S2V5cyIsImtleXMiLCJrZXkiLCJwdXNoIiwiZGFzaENhc2UiLCJzdHIiLCJyZXBsYWNlIiwicyIsImkiLCJ0b0xvd2VyQ2FzZSIsIm1hcCIsInhzIiwiZiIsInJlcyIsImxlbmd0aCIsInJlZHVjZSIsImFjYyIsIndhbGsiLCJjYW1lbCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFhOzs7O0FBRWIsSUFBSUEsT0FBTyxHQUFHQyxLQUFLLENBQUNELE9BQU4sSUFBaUIsVUFBVUUsR0FBVixFQUFlO0FBQzVDLFNBQU9DLE1BQU0sQ0FBQ0MsU0FBUCxDQUFpQkMsUUFBakIsQ0FBMEJDLElBQTFCLENBQStCSixHQUEvQixNQUF3QyxnQkFBL0M7QUFDRCxDQUZEOztBQUlBLElBQUlLLE1BQU0sR0FBRyxTQUFUQSxNQUFTLENBQVVMLEdBQVYsRUFBZTtBQUMxQixTQUFPQyxNQUFNLENBQUNDLFNBQVAsQ0FBaUJDLFFBQWpCLENBQTBCQyxJQUExQixDQUErQkosR0FBL0IsTUFBd0MsZUFBL0M7QUFDRCxDQUZEOztBQUlBLElBQUlNLE9BQU8sR0FBRyxTQUFWQSxPQUFVLENBQVVOLEdBQVYsRUFBZTtBQUMzQixTQUFPQyxNQUFNLENBQUNDLFNBQVAsQ0FBaUJDLFFBQWpCLENBQTBCQyxJQUExQixDQUErQkosR0FBL0IsTUFBd0MsaUJBQS9DO0FBQ0QsQ0FGRDs7QUFJQSxJQUFJTyxHQUFHLEdBQUdOLE1BQU0sQ0FBQ0MsU0FBUCxDQUFpQk0sY0FBM0I7O0FBQ0EsSUFBSUMsVUFBVSxHQUFHUixNQUFNLENBQUNTLElBQVAsSUFBZSxVQUFV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QzFCLEdBQUQsQ0FBWDtBQUNELENBTEQiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGFzaGVyaXplL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG52YXIgaXNEYXRlID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJztcbn07XG5cbnZhciBpc1JlZ2V4ID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufTtcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG5cbmZ1bmN0aW9uIGRhc2hDYXNlKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1tBLVpdKD86KD89W15BLVpdKXxbQS1aXSooPz1bQS1aXVteQS1aXXwkKSkvZywgZnVuY3Rpb24gKHMsIGkpIHtcbiAgICByZXR1cm4gKGkgPiAwID8gJy0nIDogJycpICsgcy50b0xvd2VyQ2FzZSgpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbWFwKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHtcbiAgICByZXR1cm4geHMubWFwKGYpO1xuICB9XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiByZWR1Y2UoeHMsIGYsIGFjYykge1xuICBpZiAoeHMucmVkdWNlKSB7XG4gICAgcmV0dXJuIHhzLnJlZHVjZShmLCBhY2MpO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICBhY2MgPSBmKGFjYywgeHNbaV0sIGkpO1xuICB9XG4gIHJldHVybiBhY2M7XG59XG5cbmZ1bmN0aW9uIHdhbGsob2JqKSB7XG4gIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBpZiAoaXNEYXRlKG9iaikgfHwgaXNSZWdleChvYmopKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG1hcChvYmosIHdhbGspO1xuICB9XG4gIHJldHVybiByZWR1Y2Uob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICB2YXIgY2FtZWwgPSBkYXNoQ2FzZShrZXkpO1xuICAgIGFjY1tjYW1lbF0gPSB3YWxrKG9ialtrZXldKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGFzaENhc2Uob2JqKTtcbiAgfVxuICByZXR1cm4gd2FsayhvYmopO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/dasherize/index.js\n");

/***/ }),

/***/ "./node_modules/mousetrap/mousetrap.js":
/*!*********************************************!*\
  !*** ./node_modules/mousetrap/mousetrap.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*global define:false */\n\n/**\n * Copyright 2012-2017 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.6.2\n * @url craig.is/killing/mice\n */\n(function (window, document, undefined) {\n  // Check if mousetrap is used inside browser, if not, return\n  if (!window) {\n    return;\n  }\n  /**\n   * mapping of special keycodes to their corresponding keys\n   *\n   * everything in this dictionary cannot use keypress events\n   * so it has to be here to map to the correct keycodes for\n   * keyup/keydown events\n   *\n   * @type {Object}\n   */\n\n\n  var _MAP = {\n    8: 'backspace',\n    9: 'tab',\n    13: 'enter',\n    16: 'shift',\n    17: 'ctrl',\n    18: 'alt',\n    20: 'capslock',\n    27: 'esc',\n    32: 'space',\n    33: 'pageup',\n    34: 'pagedown',\n    35: 'end',\n    36: 'home',\n    37: 'left',\n    38: 'up',\n    39: 'right',\n    40: 'down',\n    45: 'ins',\n    46: 'del',\n    91: 'meta',\n    93: 'meta',\n    224: 'meta'\n  };\n  /**\n   * mapping for special characters so they can support\n   *\n   * this dictionary is only used incase you want to bind a\n   * keyup or keydown event to one of these keys\n   *\n   * @type {Object}\n   */\n\n  var _KEYCODE_MAP = {\n    106: '*',\n    107: '+',\n    109: '-',\n    110: '.',\n    111: '/',\n    186: ';',\n    187: '=',\n    188: ',',\n    189: '-',\n    190: '.',\n    191: '/',\n    192: '`',\n    219: '[',\n    220: '\\\\',\n    221: ']',\n    222: '\\''\n  };\n  /**\n   * this is a mapping of keys that require shift on a US keypad\n   * back to the non shift equivelents\n   *\n   * this is so you can use keyup events with these keys\n   *\n   * note that this will only work reliably on US keyboards\n   *\n   * @type {Object}\n   */\n\n  var _SHIFT_MAP = {\n    '~': '`',\n    '!': '1',\n    '@': '2',\n    '#': '3',\n    '$': '4',\n    '%': '5',\n    '^': '6',\n    '&': '7',\n    '*': '8',\n    '(': '9',\n    ')': '0',\n    '_': '-',\n    '+': '=',\n    ':': ';',\n    '\\\"': '\\'',\n    '<': ',',\n    '>': '.',\n    '?': '/',\n    '|': '\\\\'\n  };\n  /**\n   * this is a list of special strings you can use to map\n   * to modifier keys when you specify your keyboard shortcuts\n   *\n   * @type {Object}\n   */\n\n  var _SPECIAL_ALIASES = {\n    'option': 'alt',\n    'command': 'meta',\n    'return': 'enter',\n    'escape': 'esc',\n    'plus': '+',\n    'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n  };\n  /**\n   * variable to store the flipped version of _MAP from above\n   * needed to check if we should use keypress or not when no action\n   * is specified\n   *\n   * @type {Object|undefined}\n   */\n\n  var _REVERSE_MAP;\n  /**\n   * loop through the f keys, f1 to f19 and add them to the map\n   * programatically\n   */\n\n\n  for (var i = 1; i < 20; ++i) {\n    _MAP[111 + i] = 'f' + i;\n  }\n  /**\n   * loop through to map numbers on the numeric keypad\n   */\n\n\n  for (i = 0; i <= 9; ++i) {\n    // This needs to use a string cause otherwise since 0 is falsey\n    // mousetrap will never fire for numpad 0 pressed as part of a keydown\n    // event.\n    //\n    // @see https://github.com/ccampbell/mousetrap/pull/258\n    _MAP[i + 96] = i.toString();\n  }\n  /**\n   * cross browser add event method\n   *\n   * @param {Element|HTMLDocument} object\n   * @param {string} type\n   * @param {Function} callback\n   * @returns void\n   */\n\n\n  function _addEvent(object, type, callback) {\n    if (object.addEventListener) {\n      object.addEventListener(type, callback, false);\n      return;\n    }\n\n    object.attachEvent('on' + type, callback);\n  }\n  /**\n   * takes the event and returns the key character\n   *\n   * @param {Event} e\n   * @return {string}\n   */\n\n\n  function _characterFromEvent(e) {\n    // for keypress events we should return the character as is\n    if (e.type == 'keypress') {\n      var character = String.fromCharCode(e.which); // if the shift key is not pressed then it is safe to assume\n      // that we want the character to be lowercase.  this means if\n      // you accidentally have caps lock on then your key bindings\n      // will continue to work\n      //\n      // the only side effect that might not be desired is if you\n      // bind something like 'A' cause you want to trigger an\n      // event when capital A is pressed caps lock will no longer\n      // trigger the event.  shift+a will though.\n\n      if (!e.shiftKey) {\n        character = character.toLowerCase();\n      }\n\n      return character;\n    } // for non keypress events the special maps are needed\n\n\n    if (_MAP[e.which]) {\n      return _MAP[e.which];\n    }\n\n    if (_KEYCODE_MAP[e.which]) {\n      return _KEYCODE_MAP[e.which];\n    } // if it is not in the special map\n    // with keydown and keyup events the character seems to always\n    // come in as an uppercase character whether you are pressing shift\n    // or not.  we should make sure it is always lowercase for comparisons\n\n\n    return String.fromCharCode(e.which).toLowerCase();\n  }\n  /**\n   * checks if two arrays are equal\n   *\n   * @param {Array} modifiers1\n   * @param {Array} modifiers2\n   * @returns {boolean}\n   */\n\n\n  function _modifiersMatch(modifiers1, modifiers2) {\n    return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n  }\n  /**\n   * takes a key event and figures out what the modifiers are\n   *\n   * @param {Event} e\n   * @returns {Array}\n   */\n\n\n  function _eventModifiers(e) {\n    var modifiers = [];\n\n    if (e.shiftKey) {\n      modifiers.push('shift');\n    }\n\n    if (e.altKey) {\n      modifiers.push('alt');\n    }\n\n    if (e.ctrlKey) {\n      modifiers.push('ctrl');\n    }\n\n    if (e.metaKey) {\n      modifiers.push('meta');\n    }\n\n    return modifiers;\n  }\n  /**\n   * prevents default for this event\n   *\n   * @param {Event} e\n   * @returns void\n   */\n\n\n  function _preventDefault(e) {\n    if (e.preventDefault) {\n      e.preventDefault();\n      return;\n    }\n\n    e.returnValue = false;\n  }\n  /**\n   * stops propogation for this event\n   *\n   * @param {Event} e\n   * @returns void\n   */\n\n\n  function _stopPropagation(e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n      return;\n    }\n\n    e.cancelBubble = true;\n  }\n  /**\n   * determines if the keycode specified is a modifier key or not\n   *\n   * @param {string} key\n   * @returns {boolean}\n   */\n\n\n  function _isModifier(key) {\n    return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n  }\n  /**\n   * reverses the map lookup so that we can look for specific keys\n   * to see what can and can't use keypress\n   *\n   * @return {Object}\n   */\n\n\n  function _getReverseMap() {\n    if (!_REVERSE_MAP) {\n      _REVERSE_MAP = {};\n\n      for (var key in _MAP) {\n        // pull out the numeric keypad from here cause keypress should\n        // be able to detect the keys from the character\n        if (key > 95 && key < 112) {\n          continue;\n        }\n\n        if (_MAP.hasOwnProperty(key)) {\n          _REVERSE_MAP[_MAP[key]] = key;\n        }\n      }\n    }\n\n    return _REVERSE_MAP;\n  }\n  /**\n   * picks the best action based on the key combination\n   *\n   * @param {string} key - character for key\n   * @param {Array} modifiers\n   * @param {string=} action passed in\n   */\n\n\n  function _pickBestAction(key, modifiers, action) {\n    // if no action was picked in we should try to pick the one\n    // that we think would work best for this key\n    if (!action) {\n      action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n    } // modifier keys don't work as expected with keypress,\n    // switch to keydown\n\n\n    if (action == 'keypress' && modifiers.length) {\n      action = 'keydown';\n    }\n\n    return action;\n  }\n  /**\n   * Converts from a string key combination to an array\n   *\n   * @param  {string} combination like \"command+shift+l\"\n   * @return {Array}\n   */\n\n\n  function _keysFromString(combination) {\n    if (combination === '+') {\n      return ['+'];\n    }\n\n    combination = combination.replace(/\\+{2}/g, '+plus');\n    return combination.split('+');\n  }\n  /**\n   * Gets info for a specific key combination\n   *\n   * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n   * @param  {string=} action\n   * @returns {Object}\n   */\n\n\n  function _getKeyInfo(combination, action) {\n    var keys;\n    var key;\n    var i;\n    var modifiers = []; // take the keys from this pattern and figure out what the actual\n    // pattern is all about\n\n    keys = _keysFromString(combination);\n\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i]; // normalize key names\n\n      if (_SPECIAL_ALIASES[key]) {\n        key = _SPECIAL_ALIASES[key];\n      } // if this is not a keypress event then we should\n      // be smart about using shift keys\n      // this will only work for US keyboards however\n\n\n      if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n        key = _SHIFT_MAP[key];\n        modifiers.push('shift');\n      } // if this key is a modifier then add it to the list of modifiers\n\n\n      if (_isModifier(key)) {\n        modifiers.push(key);\n      }\n    } // depending on what the key combination is\n    // we will try to pick the best event for it\n\n\n    action = _pickBestAction(key, modifiers, action);\n    return {\n      key: key,\n      modifiers: modifiers,\n      action: action\n    };\n  }\n\n  function _belongsTo(element, ancestor) {\n    if (element === null || element === document) {\n      return false;\n    }\n\n    if (element === ancestor) {\n      return true;\n    }\n\n    return _belongsTo(element.parentNode, ancestor);\n  }\n\n  function Mousetrap(targetElement) {\n    var self = this;\n    targetElement = targetElement || document;\n\n    if (!(self instanceof Mousetrap)) {\n      return new Mousetrap(targetElement);\n    }\n    /**\n     * element to attach key events to\n     *\n     * @type {Element}\n     */\n\n\n    self.target = targetElement;\n    /**\n     * a list of all the callbacks setup via Mousetrap.bind()\n     *\n     * @type {Object}\n     */\n\n    self._callbacks = {};\n    /**\n     * direct map of string combinations to callbacks used for trigger()\n     *\n     * @type {Object}\n     */\n\n    self._directMap = {};\n    /**\n     * keeps track of what level each sequence is at since multiple\n     * sequences can start out with the same sequence\n     *\n     * @type {Object}\n     */\n\n    var _sequenceLevels = {};\n    /**\n     * variable to store the setTimeout call\n     *\n     * @type {null|number}\n     */\n\n    var _resetTimer;\n    /**\n     * temporary state where we will ignore the next keyup\n     *\n     * @type {boolean|string}\n     */\n\n\n    var _ignoreNextKeyup = false;\n    /**\n     * temporary state where we will ignore the next keypress\n     *\n     * @type {boolean}\n     */\n\n    var _ignoreNextKeypress = false;\n    /**\n     * are we currently inside of a sequence?\n     * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n     *\n     * @type {boolean|string}\n     */\n\n    var _nextExpectedAction = false;\n    /**\n     * resets all sequence counters except for the ones passed in\n     *\n     * @param {Object} doNotReset\n     * @returns void\n     */\n\n    function _resetSequences(doNotReset) {\n      doNotReset = doNotReset || {};\n      var activeSequences = false,\n          key;\n\n      for (key in _sequenceLevels) {\n        if (doNotReset[key]) {\n          activeSequences = true;\n          continue;\n        }\n\n        _sequenceLevels[key] = 0;\n      }\n\n      if (!activeSequences) {\n        _nextExpectedAction = false;\n      }\n    }\n    /**\n     * finds all callbacks that match based on the keycode, modifiers,\n     * and action\n     *\n     * @param {string} character\n     * @param {Array} modifiers\n     * @param {Event|Object} e\n     * @param {string=} sequenceName - name of the sequence we are looking for\n     * @param {string=} combination\n     * @param {number=} level\n     * @returns {Array}\n     */\n\n\n    function _getMatches(character, modifiers, e, sequenceName, combination, level) {\n      var i;\n      var callback;\n      var matches = [];\n      var action = e.type; // if there are no events related to this keycode\n\n      if (!self._callbacks[character]) {\n        return [];\n      } // if a modifier key is coming up on its own we should allow it\n\n\n      if (action == 'keyup' && _isModifier(character)) {\n        modifiers = [character];\n      } // loop through all callbacks for the key that was pressed\n      // and see if any of them match\n\n\n      for (i = 0; i < self._callbacks[character].length; ++i) {\n        callback = self._callbacks[character][i]; // if a sequence name is not specified, but this is a sequence at\n        // the wrong level then move onto the next match\n\n        if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n          continue;\n        } // if the action we are looking for doesn't match the action we got\n        // then we should keep going\n\n\n        if (action != callback.action) {\n          continue;\n        } // if this is a keypress event and the meta key and control key\n        // are not pressed that means that we need to only look at the\n        // character, otherwise check the modifiers as well\n        //\n        // chrome will not fire a keypress if meta or control is down\n        // safari will fire a keypress if meta or meta+shift is down\n        // firefox will fire a keypress if meta or control is down\n\n\n        if (action == 'keypress' && !e.metaKey && !e.ctrlKey || _modifiersMatch(modifiers, callback.modifiers)) {\n          // when you bind a combination or sequence a second time it\n          // should overwrite the first one.  if a sequenceName or\n          // combination is specified in this call it does just that\n          //\n          // @todo make deleting its own method?\n          var deleteCombo = !sequenceName && callback.combo == combination;\n          var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n\n          if (deleteCombo || deleteSequence) {\n            self._callbacks[character].splice(i, 1);\n          }\n\n          matches.push(callback);\n        }\n      }\n\n      return matches;\n    }\n    /**\n     * actually calls the callback function\n     *\n     * if your callback function returns false this will use the jquery\n     * convention - prevent default and stop propogation on the event\n     *\n     * @param {Function} callback\n     * @param {Event} e\n     * @returns void\n     */\n\n\n    function _fireCallback(callback, e, combo, sequence) {\n      // if this event should not happen stop here\n      if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n        return;\n      }\n\n      if (callback(e, combo) === false) {\n        _preventDefault(e);\n\n        _stopPropagation(e);\n      }\n    }\n    /**\n     * handles a character key event\n     *\n     * @param {string} character\n     * @param {Array} modifiers\n     * @param {Event} e\n     * @returns void\n     */\n\n\n    self._handleKey = function (character, modifiers, e) {\n      var callbacks = _getMatches(character, modifiers, e);\n\n      var i;\n      var doNotReset = {};\n      var maxLevel = 0;\n      var processedSequenceCallback = false; // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n\n      for (i = 0; i < callbacks.length; ++i) {\n        if (callbacks[i].seq) {\n          maxLevel = Math.max(maxLevel, callbacks[i].level);\n        }\n      } // loop through matching callbacks for this key event\n\n\n      for (i = 0; i < callbacks.length; ++i) {\n        // fire for all sequence callbacks\n        // this is because if for example you have multiple sequences\n        // bound such as \"g i\" and \"g t\" they both need to fire the\n        // callback for matching g cause otherwise you can only ever\n        // match the first one\n        if (callbacks[i].seq) {\n          // only fire callbacks for the maxLevel to prevent\n          // subsequences from also firing\n          //\n          // for example 'a option b' should not cause 'option b' to fire\n          // even though 'option b' is part of the other sequence\n          //\n          // any sequences that do not match here will be discarded\n          // below by the _resetSequences call\n          if (callbacks[i].level != maxLevel) {\n            continue;\n          }\n\n          processedSequenceCallback = true; // keep a list of which sequences were matches for later\n\n          doNotReset[callbacks[i].seq] = 1;\n\n          _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n\n          continue;\n        } // if there were no sequence matches but we are still here\n        // that means this is a regular match so we should fire that\n\n\n        if (!processedSequenceCallback) {\n          _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n        }\n      } // if the key you pressed matches the type of sequence without\n      // being a modifier (ie \"keyup\" or \"keypress\") then we should\n      // reset all sequences that were not matched by this event\n      //\n      // this is so, for example, if you have the sequence \"h a t\" and you\n      // type \"h e a r t\" it does not match.  in this case the \"e\" will\n      // cause the sequence to reset\n      //\n      // modifier keys are ignored because you can have a sequence\n      // that contains modifiers such as \"enter ctrl+space\" and in most\n      // cases the modifier key will be pressed before the next key\n      //\n      // also if you have a sequence such as \"ctrl+b a\" then pressing the\n      // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n      //\n      // the \"keydown\" is expected when there is a modifier, but the\n      // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n      // after and that causes the sequence to reset\n      //\n      // we ignore keypresses in a sequence that directly follow a keydown\n      // for the same character\n\n\n      var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n\n      if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n        _resetSequences(doNotReset);\n      }\n\n      _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n    };\n    /**\n     * handles a keydown event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n\n\n    function _handleKeyEvent(e) {\n      // normalize e.which for key events\n      // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n      if (typeof e.which !== 'number') {\n        e.which = e.keyCode;\n      }\n\n      var character = _characterFromEvent(e); // no character found then stop\n\n\n      if (!character) {\n        return;\n      } // need to use === for the character check because the character can be 0\n\n\n      if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n        _ignoreNextKeyup = false;\n        return;\n      }\n\n      self.handleKey(character, _eventModifiers(e), e);\n    }\n    /**\n     * called to set a 1 second timeout on the specified sequence\n     *\n     * this is so after each key press in the sequence you have 1 second\n     * to press the next key before you have to start over\n     *\n     * @returns void\n     */\n\n\n    function _resetSequenceTimer() {\n      clearTimeout(_resetTimer);\n      _resetTimer = setTimeout(_resetSequences, 1000);\n    }\n    /**\n     * binds a key sequence to an event\n     *\n     * @param {string} combo - combo specified in bind call\n     * @param {Array} keys\n     * @param {Function} callback\n     * @param {string=} action\n     * @returns void\n     */\n\n\n    function _bindSequence(combo, keys, callback, action) {\n      // start off by adding a sequence level record for this combination\n      // and setting the level to 0\n      _sequenceLevels[combo] = 0;\n      /**\n       * callback to increase the sequence level for this sequence and reset\n       * all other sequences that were active\n       *\n       * @param {string} nextAction\n       * @returns {Function}\n       */\n\n      function _increaseSequence(nextAction) {\n        return function () {\n          _nextExpectedAction = nextAction;\n          ++_sequenceLevels[combo];\n\n          _resetSequenceTimer();\n        };\n      }\n      /**\n       * wraps the specified callback inside of another function in order\n       * to reset all sequence counters as soon as this sequence is done\n       *\n       * @param {Event} e\n       * @returns void\n       */\n\n\n      function _callbackAndReset(e) {\n        _fireCallback(callback, e, combo); // we should ignore the next key up if the action is key down\n        // or keypress.  this is so if you finish a sequence and\n        // release the key the final key will not trigger a keyup\n\n\n        if (action !== 'keyup') {\n          _ignoreNextKeyup = _characterFromEvent(e);\n        } // weird race condition if a sequence ends with the key\n        // another sequence begins with\n\n\n        setTimeout(_resetSequences, 10);\n      } // loop through keys one at a time and bind the appropriate callback\n      // function.  for any key leading up to the final one it should\n      // increase the sequence. after the final, it should reset all sequences\n      //\n      // if an action is specified in the original bind call then that will\n      // be used throughout.  otherwise we will pass the action that the\n      // next key in the sequence should match.  this allows a sequence\n      // to mix and match keypress and keydown events depending on which\n      // ones are better suited to the key provided\n\n\n      for (var i = 0; i < keys.length; ++i) {\n        var isFinal = i + 1 === keys.length;\n        var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n\n        _bindSingle(keys[i], wrappedCallback, action, combo, i);\n      }\n    }\n    /**\n     * binds a single keyboard combination\n     *\n     * @param {string} combination\n     * @param {Function} callback\n     * @param {string=} action\n     * @param {string=} sequenceName - name of sequence if part of sequence\n     * @param {number=} level - what part of the sequence the command is\n     * @returns void\n     */\n\n\n    function _bindSingle(combination, callback, action, sequenceName, level) {\n      // store a direct mapped reference for use with Mousetrap.trigger\n      self._directMap[combination + ':' + action] = callback; // make sure multiple spaces in a row become a single space\n\n      combination = combination.replace(/\\s+/g, ' ');\n      var sequence = combination.split(' ');\n      var info; // if this pattern is a sequence of keys then run through this method\n      // to reprocess each pattern one key at a time\n\n      if (sequence.length > 1) {\n        _bindSequence(combination, sequence, callback, action);\n\n        return;\n      }\n\n      info = _getKeyInfo(combination, action); // make sure to initialize array if this is the first time\n      // a callback is added for this key\n\n      self._callbacks[info.key] = self._callbacks[info.key] || []; // remove an existing match if there is one\n\n      _getMatches(info.key, info.modifiers, {\n        type: info.action\n      }, sequenceName, combination, level); // add this call back to the array\n      // if it is a sequence put it at the beginning\n      // if not put it at the end\n      //\n      // this is important because the way these are processed expects\n      // the sequence ones to come first\n\n\n      self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n        callback: callback,\n        modifiers: info.modifiers,\n        action: info.action,\n        seq: sequenceName,\n        level: level,\n        combo: combination\n      });\n    }\n    /**\n     * binds multiple combinations to the same callback\n     *\n     * @param {Array} combinations\n     * @param {Function} callback\n     * @param {string|undefined} action\n     * @returns void\n     */\n\n\n    self._bindMultiple = function (combinations, callback, action) {\n      for (var i = 0; i < combinations.length; ++i) {\n        _bindSingle(combinations[i], callback, action);\n      }\n    }; // start!\n\n\n    _addEvent(targetElement, 'keypress', _handleKeyEvent);\n\n    _addEvent(targetElement, 'keydown', _handleKeyEvent);\n\n    _addEvent(targetElement, 'keyup', _handleKeyEvent);\n  }\n  /**\n   * binds an event to mousetrap\n   *\n   * can be a single key, a combination of keys separated with +,\n   * an array of keys, or a sequence of keys separated by spaces\n   *\n   * be sure to list the modifier keys first to make sure that the\n   * correct key ends up getting bound (the last key in the pattern)\n   *\n   * @param {string|Array} keys\n   * @param {Function} callback\n   * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.bind = function (keys, callback, action) {\n    var self = this;\n    keys = keys instanceof Array ? keys : [keys];\n\n    self._bindMultiple.call(self, keys, callback, action);\n\n    return self;\n  };\n  /**\n   * unbinds an event to mousetrap\n   *\n   * the unbinding sets the callback function of the specified key combo\n   * to an empty function and deletes the corresponding key in the\n   * _directMap dict.\n   *\n   * TODO: actually remove this from the _callbacks dictionary instead\n   * of binding an empty function\n   *\n   * the keycombo+action has to be exactly the same as\n   * it was defined in the bind method\n   *\n   * @param {string|Array} keys\n   * @param {string} action\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.unbind = function (keys, action) {\n    var self = this;\n    return self.bind.call(self, keys, function () {}, action);\n  };\n  /**\n   * triggers an event that has already been bound\n   *\n   * @param {string} keys\n   * @param {string=} action\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.trigger = function (keys, action) {\n    var self = this;\n\n    if (self._directMap[keys + ':' + action]) {\n      self._directMap[keys + ':' + action]({}, keys);\n    }\n\n    return self;\n  };\n  /**\n   * resets the library back to its initial state.  this is useful\n   * if you want to clear out the current keyboard shortcuts and bind\n   * new ones - for example if you switch to another page\n   *\n   * @returns void\n   */\n\n\n  Mousetrap.prototype.reset = function () {\n    var self = this;\n    self._callbacks = {};\n    self._directMap = {};\n    return self;\n  };\n  /**\n   * should we stop this event before firing off callbacks\n   *\n   * @param {Event} e\n   * @param {Element} element\n   * @return {boolean}\n   */\n\n\n  Mousetrap.prototype.stopCallback = function (e, element) {\n    var self = this; // if the element has the class \"mousetrap\" then no need to stop\n\n    if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n      return false;\n    }\n\n    if (_belongsTo(element, self.target)) {\n      return false;\n    } // stop for input, select, and textarea\n\n\n    return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n  };\n  /**\n   * exposes _handleKey publicly so it can be overwritten by extensions\n   */\n\n\n  Mousetrap.prototype.handleKey = function () {\n    var self = this;\n    return self._handleKey.apply(self, arguments);\n  };\n  /**\n   * allow custom key mappings\n   */\n\n\n  Mousetrap.addKeycodes = function (object) {\n    for (var key in object) {\n      if (object.hasOwnProperty(key)) {\n        _MAP[key] = object[key];\n      }\n    }\n\n    _REVERSE_MAP = null;\n  };\n  /**\n   * Init the global mousetrap functions\n   *\n   * This method is needed to allow the global mousetrap functions to work\n   * now that mousetrap is a constructor function.\n   */\n\n\n  Mousetrap.init = function () {\n    var documentMousetrap = Mousetrap(document);\n\n    for (var method in documentMousetrap) {\n      if (method.charAt(0) !== '_') {\n        Mousetrap[method] = function (method) {\n          return function () {\n            return documentMousetrap[method].apply(documentMousetrap, arguments);\n          };\n        }(method);\n      }\n    }\n  };\n\n  Mousetrap.init(); // expose mousetrap to the global object\n\n  window.Mousetrap = Mousetrap; // expose as a common js module\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = Mousetrap;\n  } // expose mousetrap as an AMD module\n\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return Mousetrap;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n})(typeof window !== 'undefined' ? window : null, typeof window !== 'undefined' ? document : null);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW91c2V0cmFwL21vdXNldHJhcC5qcz84YTYwIl0sIm5hbWVzIjpbIndpbmRvdyIsImRvY3VtZW50IiwidW5kZWZpbmVkIiwiX01BUCIsIl9LRVlDT0RFX01BUCIsIl9TSElGVF9NQVAiLCJfU1BFQ0lBTF9BTElBU0VTIiwidGVzdCIsIm5hdmlnYXRvciIsInBsYXRmb3JtIiwiX1JFVkVSU0VfTUFQIiwiaSIsInRvU3RyaW5nIiwiX2FkZEV2ZW50Iiwib2JqZWN0IiwidHlwZSIsImNhbGxiYWNrIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiX2NoYXJhY3RlckZyb21FdmVudCIsImUiLCJjaGFyYWN0ZXIiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJ3aGljaCIsInNoaWZ0S2V5IiwidG9Mb3dlckNhc2UiLCJfbW9kaWZpZXJzTWF0Y2giLCJtb2RpZmllcnMxIiwibW9kaWZpZXJzMiIsInNvcnQiLCJqb2luIiwiX2V2ZW50TW9kaWZpZXJzIiwibW9kaWZpZXJzIiwicHVzaCIsImFsdEtleSIsImN0cmxLZXkiLCJtZXRhS2V5IiwiX3ByZXZlbnREZWZhdWx0IiwicHJldmVudERlZmF1bHQiLCJyZXR1cm5WYWx1ZSIsIl9zdG9wUHJvcGFnYXRpb24iLCJzdG9wUHJvcGFnYXRpb24iLCJjYW5jZWxCdWJibGUiLCJfaXNNb2RpZmllciIsImtleSIsIl9nZXRSZXZlcnNlTWFwIiwiaGFzT3duUHJvcGVydHkiLCJfcGlja0Jlc3RBY3Rpb24iLCJhY3Rpb24iLCJsZW5ndGgiLCJfa2V5c0Zyb21TdHJpbmciLCJjb21iaW5hdGlvbiIsInJlcGxhY2UiLCJzcGxpdCIsIl9nZXRLZXlJbmZvIiwia2V5cyIsIl9iZWxvbmdzVG8iLCJlbGVtZW50IiwiYW5jZXN0b3IiLCJwYXJlbnROb2RlIiwiTW91c2V0cmFwIiwidGFyZ2V0RWxlbWVudCIsInNlbGYiLCJ0YXJnZXQiLCJfY2FsbGJhY2tzIiwiX2RpcmVjdE1hcCIsIl9zZXF1ZW5jZUxldmVscyIsIl9yZXNldFRpbWVyIiwiX2lnbm9yZU5leHRLZXl1cCIsIl9pZ25vcmVOZXh0S2V5cHJlc3MiLCJfbmV4dEV4cGVjdGVkQWN0aW9uIiwiX3Jlc2V0U2VxdWVuY2VzIiwiZG9Ob3RSZXNldCIsImFjdGl2ZVNlcXVlbmNlcyIsIl9nZXRNYXRjaGVzIiwic2VxdWVuY2VOYW1lIiwibGV2ZWwiLCJtYXRjaGVzIiwic2VxIiwiZGVsZXRlQ29tYm8iLCJjb21ibyIsImRlbGV0ZVNlcXVlbmNlIiwic3BsaWNlIiwiX2ZpcmVDYWxsYmFjayIsInNlcXVlbmNlIiwic3RvcENhbGxiYWNrIiwic3JjRWxlbWVudCIsIl9oYW5kbGVLZXkiLCJjYWxsYmFja3MiLCJtYXhMZXZlbCIsInByb2Nlc3NlZFNlcXVlbmNlQ2FsbGJhY2siLCJNYXRoIiwibWF4IiwiaWdub3JlVGhpc0tleXByZXNzIiwiX2hhbmRsZUtleUV2ZW50Iiwia2V5Q29kZSIsImhhbmRsZUtleSIsIl9yZXNldFNlcXVlbmNlVGltZXIiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiX2JpbmRTZXF1ZW5jZSIsIl9pbmNyZWFzZVNlcXVlbmNlIiwibmV4dEFjdGlvbiIsIl9jYWxsYmFja0FuZFJlc2V0IiwiaXNGaW5hbCIsIndyYXBwZWRDYWxsYmFjayIsIl9iaW5kU2luZ2xlIiwiaW5mbyIsIl9iaW5kTXVsdGlwbGUiLCJjb21iaW5hdGlvbnMiLCJwcm90b3R5cGUiLCJiaW5kIiwiQXJyYXkiLCJjYWxsIiwidW5iaW5kIiwidHJpZ2dlciIsInJlc2V0IiwiY2xhc3NOYW1lIiwiaW5kZXhPZiIsInRhZ05hbWUiLCJpc0NvbnRlbnRFZGl0YWJsZSIsImFwcGx5IiwiYXJndW1lbnRzIiwiYWRkS2V5Y29kZXMiLCJpbml0IiwiZG9jdW1lbnRNb3VzZXRyYXAiLCJtZXRob2QiLCJjaGFyQXQiLCJtb2R1bGUiLCJleHBvcnRzIiwiZGVmaW5lIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7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QUF6QixFQUE4QjtBQUMxQm5FLGlCQUFTLENBQUNrRSxNQUFELENBQVQsR0FBcUIsVUFBU0EsTUFBVCxFQUFpQjtBQUNsQyxpQkFBTyxZQUFXO0FBQ2QsbUJBQU9ELGlCQUFpQixDQUFDQyxNQUFELENBQWpCLENBQTBCTCxLQUExQixDQUFnQ0ksaUJBQWhDLEVBQW1ESCxTQUFuRCxDQUFQO0FBQ0gsV0FGRDtBQUdILFNBSm9CLENBSWxCSSxNQUprQixDQUFyQjtBQUtIO0FBQ0o7QUFDSixHQVhEOztBQWFBbEUsV0FBUyxDQUFDZ0UsSUFBVixHQTcrQm1DLENBKytCbkM7O0FBQ0E3SCxRQUFNLENBQUM2RCxTQUFQLEdBQW1CQSxTQUFuQixDQWgvQm1DLENBay9CbkM7O0FBQ0EsTUFBSSxPQUFPb0UsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0EsTUFBTSxDQUFDQyxPQUE1QyxFQUFxRDtBQUNqREQsVUFBTSxDQUFDQyxPQUFQLEdBQWlCckUsU0FBakI7QUFDSCxHQXIvQmtDLENBdS9CbkM7OztBQUNBLE1BQUksSUFBSixFQUFnRDtBQUM1Q3NFLHVDQUFPLFlBQVc7QUFDZCxhQUFPdEUsU0FBUDtBQUNILEtBRks7QUFBQSxvR0FBTjtBQUdIO0FBQ0osQ0E3L0JELEVBNi9CSSxPQUFPN0QsTUFBUCxLQUFrQixXQUFsQixHQUFnQ0EsTUFBaEMsR0FBeUMsSUE3L0I3QyxFQTYvQm1ELE9BQVFBLE1BQVIsS0FBbUIsV0FBbkIsR0FBaUNDLFFBQWpDLEdBQTRDLElBNy9CL0YiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbW91c2V0cmFwL21vdXNldHJhcC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qZ2xvYmFsIGRlZmluZTpmYWxzZSAqL1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE3IENyYWlnIENhbXBiZWxsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogTW91c2V0cmFwIGlzIGEgc2ltcGxlIGtleWJvYXJkIHNob3J0Y3V0IGxpYnJhcnkgZm9yIEphdmFzY3JpcHQgd2l0aFxuICogbm8gZXh0ZXJuYWwgZGVwZW5kZW5jaWVzXG4gKlxuICogQHZlcnNpb24gMS42LjJcbiAqIEB1cmwgY3JhaWcuaXMva2lsbGluZy9taWNlXG4gKi9cbihmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcblxuICAgIC8vIENoZWNrIGlmIG1vdXNldHJhcCBpcyB1c2VkIGluc2lkZSBicm93c2VyLCBpZiBub3QsIHJldHVyblxuICAgIGlmICghd2luZG93KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtYXBwaW5nIG9mIHNwZWNpYWwga2V5Y29kZXMgdG8gdGhlaXIgY29ycmVzcG9uZGluZyBrZXlzXG4gICAgICpcbiAgICAgKiBldmVyeXRoaW5nIGluIHRoaXMgZGljdGlvbmFyeSBjYW5ub3QgdXNlIGtleXByZXNzIGV2ZW50c1xuICAgICAqIHNvIGl0IGhhcyB0byBiZSBoZXJlIHRvIG1hcCB0byB0aGUgY29ycmVjdCBrZXljb2RlcyBmb3JcbiAgICAgKiBrZXl1cC9rZXlkb3duIGV2ZW50c1xuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB2YXIgX01BUCA9IHtcbiAgICAgICAgODogJ2JhY2tzcGFjZScsXG4gICAgICAgIDk6ICd0YWInLFxuICAgICAgICAxMzogJ2VudGVyJyxcbiAgICAgICAgMTY6ICdzaGlmdCcsXG4gICAgICAgIDE3OiAnY3RybCcsXG4gICAgICAgIDE4OiAnYWx0JyxcbiAgICAgICAgMjA6ICdjYXBzbG9jaycsXG4gICAgICAgIDI3OiAnZXNjJyxcbiAgICAgICAgMzI6ICdzcGFjZScsXG4gICAgICAgIDMzOiAncGFnZXVwJyxcbiAgICAgICAgMzQ6ICdwYWdlZG93bicsXG4gICAgICAgIDM1OiAnZW5kJyxcbiAgICAgICAgMzY6ICdob21lJyxcbiAgICAgICAgMzc6ICdsZWZ0JyxcbiAgICAgICAgMzg6ICd1cCcsXG4gICAgICAgIDM5OiAncmlnaHQnLFxuICAgICAgICA0MDogJ2Rvd24nLFxuICAgICAgICA0NTogJ2lucycsXG4gICAgICAgIDQ2OiAnZGVsJyxcbiAgICAgICAgOTE6ICdtZXRhJyxcbiAgICAgICAgOTM6ICdtZXRhJyxcbiAgICAgICAgMjI0OiAnbWV0YSdcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogbWFwcGluZyBmb3Igc3BlY2lhbCBjaGFyYWN0ZXJzIHNvIHRoZXkgY2FuIHN1cHBvcnRcbiAgICAgKlxuICAgICAqIHRoaXMgZGljdGlvbmFyeSBpcyBvbmx5IHVzZWQgaW5jYXNlIHlvdSB3YW50IHRvIGJpbmQgYVxuICAgICAqIGtleXVwIG9yIGtleWRvd24gZXZlbnQgdG8gb25lIG9mIHRoZXNlIGtleXNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdmFyIF9LRVlDT0RFX01BUCA9IHtcbiAgICAgICAgMTA2OiAnKicsXG4gICAgICAgIDEwNzogJysnLFxuICAgICAgICAxMDk6ICctJyxcbiAgICAgICAgMTEwOiAnLicsXG4gICAgICAgIDExMSA6ICcvJyxcbiAgICAgICAgMTg2OiAnOycsXG4gICAgICAgIDE4NzogJz0nLFxuICAgICAgICAxODg6ICcsJyxcbiAgICAgICAgMTg5OiAnLScsXG4gICAgICAgIDE5MDogJy4nLFxuICAgICAgICAxOTE6ICcvJyxcbiAgICAgICAgMTkyOiAnYCcsXG4gICAgICAgIDIxOTogJ1snLFxuICAgICAgICAyMjA6ICdcXFxcJyxcbiAgICAgICAgMjIxOiAnXScsXG4gICAgICAgIDIyMjogJ1xcJydcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdGhpcyBpcyBhIG1hcHBpbmcgb2Yga2V5cyB0aGF0IHJlcXVpcmUgc2hpZnQgb24gYSBVUyBrZXlwYWRcbiAgICAgKiBiYWNrIHRvIHRoZSBub24gc2hpZnQgZXF1aXZlbGVudHNcbiAgICAgKlxuICAgICAqIHRoaXMgaXMgc28geW91IGNhbiB1c2Uga2V5dXAgZXZlbnRzIHdpdGggdGhlc2Uga2V5c1xuICAgICAqXG4gICAgICogbm90ZSB0aGF0IHRoaXMgd2lsbCBvbmx5IHdvcmsgcmVsaWFibHkgb24gVVMga2V5Ym9hcmRzXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHZhciBfU0hJRlRfTUFQID0ge1xuICAgICAgICAnfic6ICdgJyxcbiAgICAgICAgJyEnOiAnMScsXG4gICAgICAgICdAJzogJzInLFxuICAgICAgICAnIyc6ICczJyxcbiAgICAgICAgJyQnOiAnNCcsXG4gICAgICAgICclJzogJzUnLFxuICAgICAgICAnXic6ICc2JyxcbiAgICAgICAgJyYnOiAnNycsXG4gICAgICAgICcqJzogJzgnLFxuICAgICAgICAnKCc6ICc5JyxcbiAgICAgICAgJyknOiAnMCcsXG4gICAgICAgICdfJzogJy0nLFxuICAgICAgICAnKyc6ICc9JyxcbiAgICAgICAgJzonOiAnOycsXG4gICAgICAgICdcXFwiJzogJ1xcJycsXG4gICAgICAgICc8JzogJywnLFxuICAgICAgICAnPic6ICcuJyxcbiAgICAgICAgJz8nOiAnLycsXG4gICAgICAgICd8JzogJ1xcXFwnXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHRoaXMgaXMgYSBsaXN0IG9mIHNwZWNpYWwgc3RyaW5ncyB5b3UgY2FuIHVzZSB0byBtYXBcbiAgICAgKiB0byBtb2RpZmllciBrZXlzIHdoZW4geW91IHNwZWNpZnkgeW91ciBrZXlib2FyZCBzaG9ydGN1dHNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdmFyIF9TUEVDSUFMX0FMSUFTRVMgPSB7XG4gICAgICAgICdvcHRpb24nOiAnYWx0JyxcbiAgICAgICAgJ2NvbW1hbmQnOiAnbWV0YScsXG4gICAgICAgICdyZXR1cm4nOiAnZW50ZXInLFxuICAgICAgICAnZXNjYXBlJzogJ2VzYycsXG4gICAgICAgICdwbHVzJzogJysnLFxuICAgICAgICAnbW9kJzogL01hY3xpUG9kfGlQaG9uZXxpUGFkLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgPyAnbWV0YScgOiAnY3RybCdcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdmFyaWFibGUgdG8gc3RvcmUgdGhlIGZsaXBwZWQgdmVyc2lvbiBvZiBfTUFQIGZyb20gYWJvdmVcbiAgICAgKiBuZWVkZWQgdG8gY2hlY2sgaWYgd2Ugc2hvdWxkIHVzZSBrZXlwcmVzcyBvciBub3Qgd2hlbiBubyBhY3Rpb25cbiAgICAgKiBpcyBzcGVjaWZpZWRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHZhciBfUkVWRVJTRV9NQVA7XG5cbiAgICAvKipcbiAgICAgKiBsb29wIHRocm91Z2ggdGhlIGYga2V5cywgZjEgdG8gZjE5IGFuZCBhZGQgdGhlbSB0byB0aGUgbWFwXG4gICAgICogcHJvZ3JhbWF0aWNhbGx5XG4gICAgICovXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCAyMDsgKytpKSB7XG4gICAgICAgIF9NQVBbMTExICsgaV0gPSAnZicgKyBpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGxvb3AgdGhyb3VnaCB0byBtYXAgbnVtYmVycyBvbiB0aGUgbnVtZXJpYyBrZXlwYWRcbiAgICAgKi9cbiAgICBmb3IgKGkgPSAwOyBpIDw9IDk7ICsraSkge1xuXG4gICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gdXNlIGEgc3RyaW5nIGNhdXNlIG90aGVyd2lzZSBzaW5jZSAwIGlzIGZhbHNleVxuICAgICAgICAvLyBtb3VzZXRyYXAgd2lsbCBuZXZlciBmaXJlIGZvciBudW1wYWQgMCBwcmVzc2VkIGFzIHBhcnQgb2YgYSBrZXlkb3duXG4gICAgICAgIC8vIGV2ZW50LlxuICAgICAgICAvL1xuICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jY2FtcGJlbGwvbW91c2V0cmFwL3B1bGwvMjU4XG4gICAgICAgIF9NQVBbaSArIDk2XSA9IGkudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjcm9zcyBicm93c2VyIGFkZCBldmVudCBtZXRob2RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudHxIVE1MRG9jdW1lbnR9IG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2FkZEV2ZW50KG9iamVjdCwgdHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKG9iamVjdC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBvYmplY3QuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqZWN0LmF0dGFjaEV2ZW50KCdvbicgKyB0eXBlLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGFrZXMgdGhlIGV2ZW50IGFuZCByZXR1cm5zIHRoZSBrZXkgY2hhcmFjdGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9jaGFyYWN0ZXJGcm9tRXZlbnQoZSkge1xuXG4gICAgICAgIC8vIGZvciBrZXlwcmVzcyBldmVudHMgd2Ugc2hvdWxkIHJldHVybiB0aGUgY2hhcmFjdGVyIGFzIGlzXG4gICAgICAgIGlmIChlLnR5cGUgPT0gJ2tleXByZXNzJykge1xuICAgICAgICAgICAgdmFyIGNoYXJhY3RlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZS53aGljaCk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBzaGlmdCBrZXkgaXMgbm90IHByZXNzZWQgdGhlbiBpdCBpcyBzYWZlIHRvIGFzc3VtZVxuICAgICAgICAgICAgLy8gdGhhdCB3ZSB3YW50IHRoZSBjaGFyYWN0ZXIgdG8gYmUgbG93ZXJjYXNlLiAgdGhpcyBtZWFucyBpZlxuICAgICAgICAgICAgLy8geW91IGFjY2lkZW50YWxseSBoYXZlIGNhcHMgbG9jayBvbiB0aGVuIHlvdXIga2V5IGJpbmRpbmdzXG4gICAgICAgICAgICAvLyB3aWxsIGNvbnRpbnVlIHRvIHdvcmtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB0aGUgb25seSBzaWRlIGVmZmVjdCB0aGF0IG1pZ2h0IG5vdCBiZSBkZXNpcmVkIGlzIGlmIHlvdVxuICAgICAgICAgICAgLy8gYmluZCBzb21ldGhpbmcgbGlrZSAnQScgY2F1c2UgeW91IHdhbnQgdG8gdHJpZ2dlciBhblxuICAgICAgICAgICAgLy8gZXZlbnQgd2hlbiBjYXBpdGFsIEEgaXMgcHJlc3NlZCBjYXBzIGxvY2sgd2lsbCBubyBsb25nZXJcbiAgICAgICAgICAgIC8vIHRyaWdnZXIgdGhlIGV2ZW50LiAgc2hpZnQrYSB3aWxsIHRob3VnaC5cbiAgICAgICAgICAgIGlmICghZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIGNoYXJhY3RlciA9IGNoYXJhY3Rlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2hhcmFjdGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZm9yIG5vbiBrZXlwcmVzcyBldmVudHMgdGhlIHNwZWNpYWwgbWFwcyBhcmUgbmVlZGVkXG4gICAgICAgIGlmIChfTUFQW2Uud2hpY2hdKSB7XG4gICAgICAgICAgICByZXR1cm4gX01BUFtlLndoaWNoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfS0VZQ09ERV9NQVBbZS53aGljaF0pIHtcbiAgICAgICAgICAgIHJldHVybiBfS0VZQ09ERV9NQVBbZS53aGljaF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBpdCBpcyBub3QgaW4gdGhlIHNwZWNpYWwgbWFwXG5cbiAgICAgICAgLy8gd2l0aCBrZXlkb3duIGFuZCBrZXl1cCBldmVudHMgdGhlIGNoYXJhY3RlciBzZWVtcyB0byBhbHdheXNcbiAgICAgICAgLy8gY29tZSBpbiBhcyBhbiB1cHBlcmNhc2UgY2hhcmFjdGVyIHdoZXRoZXIgeW91IGFyZSBwcmVzc2luZyBzaGlmdFxuICAgICAgICAvLyBvciBub3QuICB3ZSBzaG91bGQgbWFrZSBzdXJlIGl0IGlzIGFsd2F5cyBsb3dlcmNhc2UgZm9yIGNvbXBhcmlzb25zXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGUud2hpY2gpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2hlY2tzIGlmIHR3byBhcnJheXMgYXJlIGVxdWFsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnMxXG4gICAgICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzMlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9tb2RpZmllcnNNYXRjaChtb2RpZmllcnMxLCBtb2RpZmllcnMyKSB7XG4gICAgICAgIHJldHVybiBtb2RpZmllcnMxLnNvcnQoKS5qb2luKCcsJykgPT09IG1vZGlmaWVyczIuc29ydCgpLmpvaW4oJywnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0YWtlcyBhIGtleSBldmVudCBhbmQgZmlndXJlcyBvdXQgd2hhdCB0aGUgbW9kaWZpZXJzIGFyZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfZXZlbnRNb2RpZmllcnMoZSkge1xuICAgICAgICB2YXIgbW9kaWZpZXJzID0gW107XG5cbiAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIG1vZGlmaWVycy5wdXNoKCdzaGlmdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUuYWx0S2V5KSB7XG4gICAgICAgICAgICBtb2RpZmllcnMucHVzaCgnYWx0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5jdHJsS2V5KSB7XG4gICAgICAgICAgICBtb2RpZmllcnMucHVzaCgnY3RybCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUubWV0YUtleSkge1xuICAgICAgICAgICAgbW9kaWZpZXJzLnB1c2goJ21ldGEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb2RpZmllcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJldmVudHMgZGVmYXVsdCBmb3IgdGhpcyBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfcHJldmVudERlZmF1bHQoZSkge1xuICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHN0b3BzIHByb3BvZ2F0aW9uIGZvciB0aGlzIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9zdG9wUHJvcGFnYXRpb24oZSkge1xuICAgICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZGV0ZXJtaW5lcyBpZiB0aGUga2V5Y29kZSBzcGVjaWZpZWQgaXMgYSBtb2RpZmllciBrZXkgb3Igbm90XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2lzTW9kaWZpZXIoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPT0gJ3NoaWZ0JyB8fCBrZXkgPT0gJ2N0cmwnIHx8IGtleSA9PSAnYWx0JyB8fCBrZXkgPT0gJ21ldGEnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldmVyc2VzIHRoZSBtYXAgbG9va3VwIHNvIHRoYXQgd2UgY2FuIGxvb2sgZm9yIHNwZWNpZmljIGtleXNcbiAgICAgKiB0byBzZWUgd2hhdCBjYW4gYW5kIGNhbid0IHVzZSBrZXlwcmVzc1xuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9nZXRSZXZlcnNlTWFwKCkge1xuICAgICAgICBpZiAoIV9SRVZFUlNFX01BUCkge1xuICAgICAgICAgICAgX1JFVkVSU0VfTUFQID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gX01BUCkge1xuXG4gICAgICAgICAgICAgICAgLy8gcHVsbCBvdXQgdGhlIG51bWVyaWMga2V5cGFkIGZyb20gaGVyZSBjYXVzZSBrZXlwcmVzcyBzaG91bGRcbiAgICAgICAgICAgICAgICAvLyBiZSBhYmxlIHRvIGRldGVjdCB0aGUga2V5cyBmcm9tIHRoZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID4gOTUgJiYga2V5IDwgMTEyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfTUFQLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX1JFVkVSU0VfTUFQW19NQVBba2V5XV0gPSBrZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfUkVWRVJTRV9NQVA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcGlja3MgdGhlIGJlc3QgYWN0aW9uIGJhc2VkIG9uIHRoZSBrZXkgY29tYmluYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBjaGFyYWN0ZXIgZm9yIGtleVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYWN0aW9uIHBhc3NlZCBpblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9waWNrQmVzdEFjdGlvbihrZXksIG1vZGlmaWVycywgYWN0aW9uKSB7XG5cbiAgICAgICAgLy8gaWYgbm8gYWN0aW9uIHdhcyBwaWNrZWQgaW4gd2Ugc2hvdWxkIHRyeSB0byBwaWNrIHRoZSBvbmVcbiAgICAgICAgLy8gdGhhdCB3ZSB0aGluayB3b3VsZCB3b3JrIGJlc3QgZm9yIHRoaXMga2V5XG4gICAgICAgIGlmICghYWN0aW9uKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBfZ2V0UmV2ZXJzZU1hcCgpW2tleV0gPyAna2V5ZG93bicgOiAna2V5cHJlc3MnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW9kaWZpZXIga2V5cyBkb24ndCB3b3JrIGFzIGV4cGVjdGVkIHdpdGgga2V5cHJlc3MsXG4gICAgICAgIC8vIHN3aXRjaCB0byBrZXlkb3duXG4gICAgICAgIGlmIChhY3Rpb24gPT0gJ2tleXByZXNzJyAmJiBtb2RpZmllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSAna2V5ZG93bic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGZyb20gYSBzdHJpbmcga2V5IGNvbWJpbmF0aW9uIHRvIGFuIGFycmF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNvbWJpbmF0aW9uIGxpa2UgXCJjb21tYW5kK3NoaWZ0K2xcIlxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9rZXlzRnJvbVN0cmluZyhjb21iaW5hdGlvbikge1xuICAgICAgICBpZiAoY29tYmluYXRpb24gPT09ICcrJykge1xuICAgICAgICAgICAgcmV0dXJuIFsnKyddO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tYmluYXRpb24gPSBjb21iaW5hdGlvbi5yZXBsYWNlKC9cXCt7Mn0vZywgJytwbHVzJyk7XG4gICAgICAgIHJldHVybiBjb21iaW5hdGlvbi5zcGxpdCgnKycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgaW5mbyBmb3IgYSBzcGVjaWZpYyBrZXkgY29tYmluYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gY29tYmluYXRpb24ga2V5IGNvbWJpbmF0aW9uIChcImNvbW1hbmQrc1wiIG9yIFwiYVwiIG9yIFwiKlwiKVxuICAgICAqIEBwYXJhbSAge3N0cmluZz19IGFjdGlvblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2dldEtleUluZm8oY29tYmluYXRpb24sIGFjdGlvbikge1xuICAgICAgICB2YXIga2V5cztcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBtb2RpZmllcnMgPSBbXTtcblxuICAgICAgICAvLyB0YWtlIHRoZSBrZXlzIGZyb20gdGhpcyBwYXR0ZXJuIGFuZCBmaWd1cmUgb3V0IHdoYXQgdGhlIGFjdHVhbFxuICAgICAgICAvLyBwYXR0ZXJuIGlzIGFsbCBhYm91dFxuICAgICAgICBrZXlzID0gX2tleXNGcm9tU3RyaW5nKGNvbWJpbmF0aW9uKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICAgICAgLy8gbm9ybWFsaXplIGtleSBuYW1lc1xuICAgICAgICAgICAgaWYgKF9TUEVDSUFMX0FMSUFTRVNba2V5XSkge1xuICAgICAgICAgICAgICAgIGtleSA9IF9TUEVDSUFMX0FMSUFTRVNba2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBub3QgYSBrZXlwcmVzcyBldmVudCB0aGVuIHdlIHNob3VsZFxuICAgICAgICAgICAgLy8gYmUgc21hcnQgYWJvdXQgdXNpbmcgc2hpZnQga2V5c1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIG9ubHkgd29yayBmb3IgVVMga2V5Ym9hcmRzIGhvd2V2ZXJcbiAgICAgICAgICAgIGlmIChhY3Rpb24gJiYgYWN0aW9uICE9ICdrZXlwcmVzcycgJiYgX1NISUZUX01BUFtrZXldKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gX1NISUZUX01BUFtrZXldO1xuICAgICAgICAgICAgICAgIG1vZGlmaWVycy5wdXNoKCdzaGlmdCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGtleSBpcyBhIG1vZGlmaWVyIHRoZW4gYWRkIGl0IHRvIHRoZSBsaXN0IG9mIG1vZGlmaWVyc1xuICAgICAgICAgICAgaWYgKF9pc01vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllcnMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVwZW5kaW5nIG9uIHdoYXQgdGhlIGtleSBjb21iaW5hdGlvbiBpc1xuICAgICAgICAvLyB3ZSB3aWxsIHRyeSB0byBwaWNrIHRoZSBiZXN0IGV2ZW50IGZvciBpdFxuICAgICAgICBhY3Rpb24gPSBfcGlja0Jlc3RBY3Rpb24oa2V5LCBtb2RpZmllcnMsIGFjdGlvbik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnMsXG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvblxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9iZWxvbmdzVG8oZWxlbWVudCwgYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbGVtZW50ID09PSBhbmNlc3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2JlbG9uZ3NUbyhlbGVtZW50LnBhcmVudE5vZGUsIGFuY2VzdG9yKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBNb3VzZXRyYXAodGFyZ2V0RWxlbWVudCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdGFyZ2V0RWxlbWVudCA9IHRhcmdldEVsZW1lbnQgfHwgZG9jdW1lbnQ7XG5cbiAgICAgICAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIE1vdXNldHJhcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW91c2V0cmFwKHRhcmdldEVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGVsZW1lbnQgdG8gYXR0YWNoIGtleSBldmVudHMgdG9cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLnRhcmdldCA9IHRhcmdldEVsZW1lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGEgbGlzdCBvZiBhbGwgdGhlIGNhbGxiYWNrcyBzZXR1cCB2aWEgTW91c2V0cmFwLmJpbmQoKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5fY2FsbGJhY2tzID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRpcmVjdCBtYXAgb2Ygc3RyaW5nIGNvbWJpbmF0aW9ucyB0byBjYWxsYmFja3MgdXNlZCBmb3IgdHJpZ2dlcigpXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLl9kaXJlY3RNYXAgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICoga2VlcHMgdHJhY2sgb2Ygd2hhdCBsZXZlbCBlYWNoIHNlcXVlbmNlIGlzIGF0IHNpbmNlIG11bHRpcGxlXG4gICAgICAgICAqIHNlcXVlbmNlcyBjYW4gc3RhcnQgb3V0IHdpdGggdGhlIHNhbWUgc2VxdWVuY2VcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBfc2VxdWVuY2VMZXZlbHMgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogdmFyaWFibGUgdG8gc3RvcmUgdGhlIHNldFRpbWVvdXQgY2FsbFxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7bnVsbHxudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX3Jlc2V0VGltZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRlbXBvcmFyeSBzdGF0ZSB3aGVyZSB3ZSB3aWxsIGlnbm9yZSB0aGUgbmV4dCBrZXl1cFxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbnxzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX2lnbm9yZU5leHRLZXl1cCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0ZW1wb3Jhcnkgc3RhdGUgd2hlcmUgd2Ugd2lsbCBpZ25vcmUgdGhlIG5leHQga2V5cHJlc3NcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX2lnbm9yZU5leHRLZXlwcmVzcyA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhcmUgd2UgY3VycmVudGx5IGluc2lkZSBvZiBhIHNlcXVlbmNlP1xuICAgICAgICAgKiB0eXBlIG9mIGFjdGlvbiAoXCJrZXl1cFwiIG9yIFwia2V5ZG93blwiIG9yIFwia2V5cHJlc3NcIikgb3IgZmFsc2VcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW58c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIF9uZXh0RXhwZWN0ZWRBY3Rpb24gPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmVzZXRzIGFsbCBzZXF1ZW5jZSBjb3VudGVycyBleGNlcHQgZm9yIHRoZSBvbmVzIHBhc3NlZCBpblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZG9Ob3RSZXNldFxuICAgICAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfcmVzZXRTZXF1ZW5jZXMoZG9Ob3RSZXNldCkge1xuICAgICAgICAgICAgZG9Ob3RSZXNldCA9IGRvTm90UmVzZXQgfHwge307XG5cbiAgICAgICAgICAgIHZhciBhY3RpdmVTZXF1ZW5jZXMgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBrZXk7XG5cbiAgICAgICAgICAgIGZvciAoa2V5IGluIF9zZXF1ZW5jZUxldmVscykge1xuICAgICAgICAgICAgICAgIGlmIChkb05vdFJlc2V0W2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlU2VxdWVuY2VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9zZXF1ZW5jZUxldmVsc1trZXldID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFhY3RpdmVTZXF1ZW5jZXMpIHtcbiAgICAgICAgICAgICAgICBfbmV4dEV4cGVjdGVkQWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogZmluZHMgYWxsIGNhbGxiYWNrcyB0aGF0IG1hdGNoIGJhc2VkIG9uIHRoZSBrZXljb2RlLCBtb2RpZmllcnMsXG4gICAgICAgICAqIGFuZCBhY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJhY3RlclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnNcbiAgICAgICAgICogQHBhcmFtIHtFdmVudHxPYmplY3R9IGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBzZXF1ZW5jZU5hbWUgLSBuYW1lIG9mIHRoZSBzZXF1ZW5jZSB3ZSBhcmUgbG9va2luZyBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBjb21iaW5hdGlvblxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IGxldmVsXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9nZXRNYXRjaGVzKGNoYXJhY3RlciwgbW9kaWZpZXJzLCBlLCBzZXF1ZW5jZU5hbWUsIGNvbWJpbmF0aW9uLCBsZXZlbCkge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2s7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IGUudHlwZTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIGV2ZW50cyByZWxhdGVkIHRvIHRoaXMga2V5Y29kZVxuICAgICAgICAgICAgaWYgKCFzZWxmLl9jYWxsYmFja3NbY2hhcmFjdGVyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgYSBtb2RpZmllciBrZXkgaXMgY29taW5nIHVwIG9uIGl0cyBvd24gd2Ugc2hvdWxkIGFsbG93IGl0XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09ICdrZXl1cCcgJiYgX2lzTW9kaWZpZXIoY2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVycyA9IFtjaGFyYWN0ZXJdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggYWxsIGNhbGxiYWNrcyBmb3IgdGhlIGtleSB0aGF0IHdhcyBwcmVzc2VkXG4gICAgICAgICAgICAvLyBhbmQgc2VlIGlmIGFueSBvZiB0aGVtIG1hdGNoXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZi5fY2FsbGJhY2tzW2NoYXJhY3Rlcl0ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHNlbGYuX2NhbGxiYWNrc1tjaGFyYWN0ZXJdW2ldO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgYSBzZXF1ZW5jZSBuYW1lIGlzIG5vdCBzcGVjaWZpZWQsIGJ1dCB0aGlzIGlzIGEgc2VxdWVuY2UgYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgd3JvbmcgbGV2ZWwgdGhlbiBtb3ZlIG9udG8gdGhlIG5leHQgbWF0Y2hcbiAgICAgICAgICAgICAgICBpZiAoIXNlcXVlbmNlTmFtZSAmJiBjYWxsYmFjay5zZXEgJiYgX3NlcXVlbmNlTGV2ZWxzW2NhbGxiYWNrLnNlcV0gIT0gY2FsbGJhY2subGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGFjdGlvbiB3ZSBhcmUgbG9va2luZyBmb3IgZG9lc24ndCBtYXRjaCB0aGUgYWN0aW9uIHdlIGdvdFxuICAgICAgICAgICAgICAgIC8vIHRoZW4gd2Ugc2hvdWxkIGtlZXAgZ29pbmdcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9IGNhbGxiYWNrLmFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEga2V5cHJlc3MgZXZlbnQgYW5kIHRoZSBtZXRhIGtleSBhbmQgY29udHJvbCBrZXlcbiAgICAgICAgICAgICAgICAvLyBhcmUgbm90IHByZXNzZWQgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gb25seSBsb29rIGF0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlciwgb3RoZXJ3aXNlIGNoZWNrIHRoZSBtb2RpZmllcnMgYXMgd2VsbFxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gY2hyb21lIHdpbGwgbm90IGZpcmUgYSBrZXlwcmVzcyBpZiBtZXRhIG9yIGNvbnRyb2wgaXMgZG93blxuICAgICAgICAgICAgICAgIC8vIHNhZmFyaSB3aWxsIGZpcmUgYSBrZXlwcmVzcyBpZiBtZXRhIG9yIG1ldGErc2hpZnQgaXMgZG93blxuICAgICAgICAgICAgICAgIC8vIGZpcmVmb3ggd2lsbCBmaXJlIGEga2V5cHJlc3MgaWYgbWV0YSBvciBjb250cm9sIGlzIGRvd25cbiAgICAgICAgICAgICAgICBpZiAoKGFjdGlvbiA9PSAna2V5cHJlc3MnICYmICFlLm1ldGFLZXkgJiYgIWUuY3RybEtleSkgfHwgX21vZGlmaWVyc01hdGNoKG1vZGlmaWVycywgY2FsbGJhY2subW9kaWZpZXJzKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4geW91IGJpbmQgYSBjb21iaW5hdGlvbiBvciBzZXF1ZW5jZSBhIHNlY29uZCB0aW1lIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBvdmVyd3JpdGUgdGhlIGZpcnN0IG9uZS4gIGlmIGEgc2VxdWVuY2VOYW1lIG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbWJpbmF0aW9uIGlzIHNwZWNpZmllZCBpbiB0aGlzIGNhbGwgaXQgZG9lcyBqdXN0IHRoYXRcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gQHRvZG8gbWFrZSBkZWxldGluZyBpdHMgb3duIG1ldGhvZD9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGV0ZUNvbWJvID0gIXNlcXVlbmNlTmFtZSAmJiBjYWxsYmFjay5jb21ibyA9PSBjb21iaW5hdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGV0ZVNlcXVlbmNlID0gc2VxdWVuY2VOYW1lICYmIGNhbGxiYWNrLnNlcSA9PSBzZXF1ZW5jZU5hbWUgJiYgY2FsbGJhY2subGV2ZWwgPT0gbGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGVDb21ibyB8fCBkZWxldGVTZXF1ZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fY2FsbGJhY2tzW2NoYXJhY3Rlcl0uc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFjdHVhbGx5IGNhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBpZiB5b3VyIGNhbGxiYWNrIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UgdGhpcyB3aWxsIHVzZSB0aGUganF1ZXJ5XG4gICAgICAgICAqIGNvbnZlbnRpb24gLSBwcmV2ZW50IGRlZmF1bHQgYW5kIHN0b3AgcHJvcG9nYXRpb24gb24gdGhlIGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAgICogQHJldHVybnMgdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZpcmVDYWxsYmFjayhjYWxsYmFjaywgZSwgY29tYm8sIHNlcXVlbmNlKSB7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgZXZlbnQgc2hvdWxkIG5vdCBoYXBwZW4gc3RvcCBoZXJlXG4gICAgICAgICAgICBpZiAoc2VsZi5zdG9wQ2FsbGJhY2soZSwgZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LCBjb21ibywgc2VxdWVuY2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2soZSwgY29tYm8pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIF9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgICAgICAgICBfc3RvcFByb3BhZ2F0aW9uKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGhhbmRsZXMgYSBjaGFyYWN0ZXIga2V5IGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyYWN0ZXJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAgICogQHJldHVybnMgdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5faGFuZGxlS2V5ID0gZnVuY3Rpb24oY2hhcmFjdGVyLCBtb2RpZmllcnMsIGUpIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFja3MgPSBfZ2V0TWF0Y2hlcyhjaGFyYWN0ZXIsIG1vZGlmaWVycywgZSk7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIHZhciBkb05vdFJlc2V0ID0ge307XG4gICAgICAgICAgICB2YXIgbWF4TGV2ZWwgPSAwO1xuICAgICAgICAgICAgdmFyIHByb2Nlc3NlZFNlcXVlbmNlQ2FsbGJhY2sgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBtYXhMZXZlbCBmb3Igc2VxdWVuY2VzIHNvIHdlIGNhbiBvbmx5IGV4ZWN1dGUgdGhlIGxvbmdlc3QgY2FsbGJhY2sgc2VxdWVuY2VcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tzW2ldLnNlcSkge1xuICAgICAgICAgICAgICAgICAgICBtYXhMZXZlbCA9IE1hdGgubWF4KG1heExldmVsLCBjYWxsYmFja3NbaV0ubGV2ZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIG1hdGNoaW5nIGNhbGxiYWNrcyBmb3IgdGhpcyBrZXkgZXZlbnRcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICAgICAgICAgIC8vIGZpcmUgZm9yIGFsbCBzZXF1ZW5jZSBjYWxsYmFja3NcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGJlY2F1c2UgaWYgZm9yIGV4YW1wbGUgeW91IGhhdmUgbXVsdGlwbGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgICAgLy8gYm91bmQgc3VjaCBhcyBcImcgaVwiIGFuZCBcImcgdFwiIHRoZXkgYm90aCBuZWVkIHRvIGZpcmUgdGhlXG4gICAgICAgICAgICAgICAgLy8gY2FsbGJhY2sgZm9yIG1hdGNoaW5nIGcgY2F1c2Ugb3RoZXJ3aXNlIHlvdSBjYW4gb25seSBldmVyXG4gICAgICAgICAgICAgICAgLy8gbWF0Y2ggdGhlIGZpcnN0IG9uZVxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja3NbaV0uc2VxKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBmaXJlIGNhbGxiYWNrcyBmb3IgdGhlIG1heExldmVsIHRvIHByZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gc3Vic2VxdWVuY2VzIGZyb20gYWxzbyBmaXJpbmdcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGV4YW1wbGUgJ2Egb3B0aW9uIGInIHNob3VsZCBub3QgY2F1c2UgJ29wdGlvbiBiJyB0byBmaXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gdGhvdWdoICdvcHRpb24gYicgaXMgcGFydCBvZiB0aGUgb3RoZXIgc2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gYW55IHNlcXVlbmNlcyB0aGF0IGRvIG5vdCBtYXRjaCBoZXJlIHdpbGwgYmUgZGlzY2FyZGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlbG93IGJ5IHRoZSBfcmVzZXRTZXF1ZW5jZXMgY2FsbFxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tzW2ldLmxldmVsICE9IG1heExldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZFNlcXVlbmNlQ2FsbGJhY2sgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgYSBsaXN0IG9mIHdoaWNoIHNlcXVlbmNlcyB3ZXJlIG1hdGNoZXMgZm9yIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIGRvTm90UmVzZXRbY2FsbGJhY2tzW2ldLnNlcV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICBfZmlyZUNhbGxiYWNrKGNhbGxiYWNrc1tpXS5jYWxsYmFjaywgZSwgY2FsbGJhY2tzW2ldLmNvbWJvLCBjYWxsYmFja3NbaV0uc2VxKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgd2VyZSBubyBzZXF1ZW5jZSBtYXRjaGVzIGJ1dCB3ZSBhcmUgc3RpbGwgaGVyZVxuICAgICAgICAgICAgICAgIC8vIHRoYXQgbWVhbnMgdGhpcyBpcyBhIHJlZ3VsYXIgbWF0Y2ggc28gd2Ugc2hvdWxkIGZpcmUgdGhhdFxuICAgICAgICAgICAgICAgIGlmICghcHJvY2Vzc2VkU2VxdWVuY2VDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBfZmlyZUNhbGxiYWNrKGNhbGxiYWNrc1tpXS5jYWxsYmFjaywgZSwgY2FsbGJhY2tzW2ldLmNvbWJvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBrZXkgeW91IHByZXNzZWQgbWF0Y2hlcyB0aGUgdHlwZSBvZiBzZXF1ZW5jZSB3aXRob3V0XG4gICAgICAgICAgICAvLyBiZWluZyBhIG1vZGlmaWVyIChpZSBcImtleXVwXCIgb3IgXCJrZXlwcmVzc1wiKSB0aGVuIHdlIHNob3VsZFxuICAgICAgICAgICAgLy8gcmVzZXQgYWxsIHNlcXVlbmNlcyB0aGF0IHdlcmUgbm90IG1hdGNoZWQgYnkgdGhpcyBldmVudFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgc28sIGZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSB0aGUgc2VxdWVuY2UgXCJoIGEgdFwiIGFuZCB5b3VcbiAgICAgICAgICAgIC8vIHR5cGUgXCJoIGUgYSByIHRcIiBpdCBkb2VzIG5vdCBtYXRjaC4gIGluIHRoaXMgY2FzZSB0aGUgXCJlXCIgd2lsbFxuICAgICAgICAgICAgLy8gY2F1c2UgdGhlIHNlcXVlbmNlIHRvIHJlc2V0XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gbW9kaWZpZXIga2V5cyBhcmUgaWdub3JlZCBiZWNhdXNlIHlvdSBjYW4gaGF2ZSBhIHNlcXVlbmNlXG4gICAgICAgICAgICAvLyB0aGF0IGNvbnRhaW5zIG1vZGlmaWVycyBzdWNoIGFzIFwiZW50ZXIgY3RybCtzcGFjZVwiIGFuZCBpbiBtb3N0XG4gICAgICAgICAgICAvLyBjYXNlcyB0aGUgbW9kaWZpZXIga2V5IHdpbGwgYmUgcHJlc3NlZCBiZWZvcmUgdGhlIG5leHQga2V5XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gYWxzbyBpZiB5b3UgaGF2ZSBhIHNlcXVlbmNlIHN1Y2ggYXMgXCJjdHJsK2IgYVwiIHRoZW4gcHJlc3NpbmcgdGhlXG4gICAgICAgICAgICAvLyBcImJcIiBrZXkgd2lsbCB0cmlnZ2VyIGEgXCJrZXlwcmVzc1wiIGFuZCBhIFwia2V5ZG93blwiXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gdGhlIFwia2V5ZG93blwiIGlzIGV4cGVjdGVkIHdoZW4gdGhlcmUgaXMgYSBtb2RpZmllciwgYnV0IHRoZVxuICAgICAgICAgICAgLy8gXCJrZXlwcmVzc1wiIGVuZHMgdXAgbWF0Y2hpbmcgdGhlIF9uZXh0RXhwZWN0ZWRBY3Rpb24gc2luY2UgaXQgb2NjdXJzXG4gICAgICAgICAgICAvLyBhZnRlciBhbmQgdGhhdCBjYXVzZXMgdGhlIHNlcXVlbmNlIHRvIHJlc2V0XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gd2UgaWdub3JlIGtleXByZXNzZXMgaW4gYSBzZXF1ZW5jZSB0aGF0IGRpcmVjdGx5IGZvbGxvdyBhIGtleWRvd25cbiAgICAgICAgICAgIC8vIGZvciB0aGUgc2FtZSBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHZhciBpZ25vcmVUaGlzS2V5cHJlc3MgPSBlLnR5cGUgPT0gJ2tleXByZXNzJyAmJiBfaWdub3JlTmV4dEtleXByZXNzO1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PSBfbmV4dEV4cGVjdGVkQWN0aW9uICYmICFfaXNNb2RpZmllcihjaGFyYWN0ZXIpICYmICFpZ25vcmVUaGlzS2V5cHJlc3MpIHtcbiAgICAgICAgICAgICAgICBfcmVzZXRTZXF1ZW5jZXMoZG9Ob3RSZXNldCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9pZ25vcmVOZXh0S2V5cHJlc3MgPSBwcm9jZXNzZWRTZXF1ZW5jZUNhbGxiYWNrICYmIGUudHlwZSA9PSAna2V5ZG93bic7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGhhbmRsZXMgYSBrZXlkb3duIGV2ZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAgICogQHJldHVybnMgdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2hhbmRsZUtleUV2ZW50KGUpIHtcblxuICAgICAgICAgICAgLy8gbm9ybWFsaXplIGUud2hpY2ggZm9yIGtleSBldmVudHNcbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80Mjg1NjI3L2phdmFzY3JpcHQta2V5Y29kZS12cy1jaGFyY29kZS11dHRlci1jb25mdXNpb25cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZS53aGljaCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBlLndoaWNoID0gZS5rZXlDb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2hhcmFjdGVyID0gX2NoYXJhY3RlckZyb21FdmVudChlKTtcblxuICAgICAgICAgICAgLy8gbm8gY2hhcmFjdGVyIGZvdW5kIHRoZW4gc3RvcFxuICAgICAgICAgICAgaWYgKCFjaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5lZWQgdG8gdXNlID09PSBmb3IgdGhlIGNoYXJhY3RlciBjaGVjayBiZWNhdXNlIHRoZSBjaGFyYWN0ZXIgY2FuIGJlIDBcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT0gJ2tleXVwJyAmJiBfaWdub3JlTmV4dEtleXVwID09PSBjaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICBfaWdub3JlTmV4dEtleXVwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLmhhbmRsZUtleShjaGFyYWN0ZXIsIF9ldmVudE1vZGlmaWVycyhlKSwgZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogY2FsbGVkIHRvIHNldCBhIDEgc2Vjb25kIHRpbWVvdXQgb24gdGhlIHNwZWNpZmllZCBzZXF1ZW5jZVxuICAgICAgICAgKlxuICAgICAgICAgKiB0aGlzIGlzIHNvIGFmdGVyIGVhY2gga2V5IHByZXNzIGluIHRoZSBzZXF1ZW5jZSB5b3UgaGF2ZSAxIHNlY29uZFxuICAgICAgICAgKiB0byBwcmVzcyB0aGUgbmV4dCBrZXkgYmVmb3JlIHlvdSBoYXZlIHRvIHN0YXJ0IG92ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX3Jlc2V0U2VxdWVuY2VUaW1lcigpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfcmVzZXRUaW1lcik7XG4gICAgICAgICAgICBfcmVzZXRUaW1lciA9IHNldFRpbWVvdXQoX3Jlc2V0U2VxdWVuY2VzLCAxMDAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBiaW5kcyBhIGtleSBzZXF1ZW5jZSB0byBhbiBldmVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29tYm8gLSBjb21ibyBzcGVjaWZpZWQgaW4gYmluZCBjYWxsXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGtleXNcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBhY3Rpb25cbiAgICAgICAgICogQHJldHVybnMgdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2JpbmRTZXF1ZW5jZShjb21ibywga2V5cywgY2FsbGJhY2ssIGFjdGlvbikge1xuXG4gICAgICAgICAgICAvLyBzdGFydCBvZmYgYnkgYWRkaW5nIGEgc2VxdWVuY2UgbGV2ZWwgcmVjb3JkIGZvciB0aGlzIGNvbWJpbmF0aW9uXG4gICAgICAgICAgICAvLyBhbmQgc2V0dGluZyB0aGUgbGV2ZWwgdG8gMFxuICAgICAgICAgICAgX3NlcXVlbmNlTGV2ZWxzW2NvbWJvXSA9IDA7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogY2FsbGJhY2sgdG8gaW5jcmVhc2UgdGhlIHNlcXVlbmNlIGxldmVsIGZvciB0aGlzIHNlcXVlbmNlIGFuZCByZXNldFxuICAgICAgICAgICAgICogYWxsIG90aGVyIHNlcXVlbmNlcyB0aGF0IHdlcmUgYWN0aXZlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5leHRBY3Rpb25cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gX2luY3JlYXNlU2VxdWVuY2UobmV4dEFjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgX25leHRFeHBlY3RlZEFjdGlvbiA9IG5leHRBY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICsrX3NlcXVlbmNlTGV2ZWxzW2NvbWJvXTtcbiAgICAgICAgICAgICAgICAgICAgX3Jlc2V0U2VxdWVuY2VUaW1lcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogd3JhcHMgdGhlIHNwZWNpZmllZCBjYWxsYmFjayBpbnNpZGUgb2YgYW5vdGhlciBmdW5jdGlvbiBpbiBvcmRlclxuICAgICAgICAgICAgICogdG8gcmVzZXQgYWxsIHNlcXVlbmNlIGNvdW50ZXJzIGFzIHNvb24gYXMgdGhpcyBzZXF1ZW5jZSBpcyBkb25lXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICAgICAgICogQHJldHVybnMgdm9pZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBfY2FsbGJhY2tBbmRSZXNldChlKSB7XG4gICAgICAgICAgICAgICAgX2ZpcmVDYWxsYmFjayhjYWxsYmFjaywgZSwgY29tYm8pO1xuXG4gICAgICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIGlnbm9yZSB0aGUgbmV4dCBrZXkgdXAgaWYgdGhlIGFjdGlvbiBpcyBrZXkgZG93blxuICAgICAgICAgICAgICAgIC8vIG9yIGtleXByZXNzLiAgdGhpcyBpcyBzbyBpZiB5b3UgZmluaXNoIGEgc2VxdWVuY2UgYW5kXG4gICAgICAgICAgICAgICAgLy8gcmVsZWFzZSB0aGUga2V5IHRoZSBmaW5hbCBrZXkgd2lsbCBub3QgdHJpZ2dlciBhIGtleXVwXG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ2tleXVwJykge1xuICAgICAgICAgICAgICAgICAgICBfaWdub3JlTmV4dEtleXVwID0gX2NoYXJhY3RlckZyb21FdmVudChlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB3ZWlyZCByYWNlIGNvbmRpdGlvbiBpZiBhIHNlcXVlbmNlIGVuZHMgd2l0aCB0aGUga2V5XG4gICAgICAgICAgICAgICAgLy8gYW5vdGhlciBzZXF1ZW5jZSBiZWdpbnMgd2l0aFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoX3Jlc2V0U2VxdWVuY2VzLCAxMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBrZXlzIG9uZSBhdCBhIHRpbWUgYW5kIGJpbmQgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrXG4gICAgICAgICAgICAvLyBmdW5jdGlvbi4gIGZvciBhbnkga2V5IGxlYWRpbmcgdXAgdG8gdGhlIGZpbmFsIG9uZSBpdCBzaG91bGRcbiAgICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBzZXF1ZW5jZS4gYWZ0ZXIgdGhlIGZpbmFsLCBpdCBzaG91bGQgcmVzZXQgYWxsIHNlcXVlbmNlc1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGlmIGFuIGFjdGlvbiBpcyBzcGVjaWZpZWQgaW4gdGhlIG9yaWdpbmFsIGJpbmQgY2FsbCB0aGVuIHRoYXQgd2lsbFxuICAgICAgICAgICAgLy8gYmUgdXNlZCB0aHJvdWdob3V0LiAgb3RoZXJ3aXNlIHdlIHdpbGwgcGFzcyB0aGUgYWN0aW9uIHRoYXQgdGhlXG4gICAgICAgICAgICAvLyBuZXh0IGtleSBpbiB0aGUgc2VxdWVuY2Ugc2hvdWxkIG1hdGNoLiAgdGhpcyBhbGxvd3MgYSBzZXF1ZW5jZVxuICAgICAgICAgICAgLy8gdG8gbWl4IGFuZCBtYXRjaCBrZXlwcmVzcyBhbmQga2V5ZG93biBldmVudHMgZGVwZW5kaW5nIG9uIHdoaWNoXG4gICAgICAgICAgICAvLyBvbmVzIGFyZSBiZXR0ZXIgc3VpdGVkIHRvIHRoZSBrZXkgcHJvdmlkZWRcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBpc0ZpbmFsID0gaSArIDEgPT09IGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciB3cmFwcGVkQ2FsbGJhY2sgPSBpc0ZpbmFsID8gX2NhbGxiYWNrQW5kUmVzZXQgOiBfaW5jcmVhc2VTZXF1ZW5jZShhY3Rpb24gfHwgX2dldEtleUluZm8oa2V5c1tpICsgMV0pLmFjdGlvbik7XG4gICAgICAgICAgICAgICAgX2JpbmRTaW5nbGUoa2V5c1tpXSwgd3JhcHBlZENhbGxiYWNrLCBhY3Rpb24sIGNvbWJvLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBiaW5kcyBhIHNpbmdsZSBrZXlib2FyZCBjb21iaW5hdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29tYmluYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBhY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBzZXF1ZW5jZU5hbWUgLSBuYW1lIG9mIHNlcXVlbmNlIGlmIHBhcnQgb2Ygc2VxdWVuY2VcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBsZXZlbCAtIHdoYXQgcGFydCBvZiB0aGUgc2VxdWVuY2UgdGhlIGNvbW1hbmQgaXNcbiAgICAgICAgICogQHJldHVybnMgdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2JpbmRTaW5nbGUoY29tYmluYXRpb24sIGNhbGxiYWNrLCBhY3Rpb24sIHNlcXVlbmNlTmFtZSwgbGV2ZWwpIHtcblxuICAgICAgICAgICAgLy8gc3RvcmUgYSBkaXJlY3QgbWFwcGVkIHJlZmVyZW5jZSBmb3IgdXNlIHdpdGggTW91c2V0cmFwLnRyaWdnZXJcbiAgICAgICAgICAgIHNlbGYuX2RpcmVjdE1hcFtjb21iaW5hdGlvbiArICc6JyArIGFjdGlvbl0gPSBjYWxsYmFjaztcblxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIG11bHRpcGxlIHNwYWNlcyBpbiBhIHJvdyBiZWNvbWUgYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgICAgIGNvbWJpbmF0aW9uID0gY29tYmluYXRpb24ucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuXG4gICAgICAgICAgICB2YXIgc2VxdWVuY2UgPSBjb21iaW5hdGlvbi5zcGxpdCgnICcpO1xuICAgICAgICAgICAgdmFyIGluZm87XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgcGF0dGVybiBpcyBhIHNlcXVlbmNlIG9mIGtleXMgdGhlbiBydW4gdGhyb3VnaCB0aGlzIG1ldGhvZFxuICAgICAgICAgICAgLy8gdG8gcmVwcm9jZXNzIGVhY2ggcGF0dGVybiBvbmUga2V5IGF0IGEgdGltZVxuICAgICAgICAgICAgaWYgKHNlcXVlbmNlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBfYmluZFNlcXVlbmNlKGNvbWJpbmF0aW9uLCBzZXF1ZW5jZSwgY2FsbGJhY2ssIGFjdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbmZvID0gX2dldEtleUluZm8oY29tYmluYXRpb24sIGFjdGlvbik7XG5cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbml0aWFsaXplIGFycmF5IGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICAgIC8vIGEgY2FsbGJhY2sgaXMgYWRkZWQgZm9yIHRoaXMga2V5XG4gICAgICAgICAgICBzZWxmLl9jYWxsYmFja3NbaW5mby5rZXldID0gc2VsZi5fY2FsbGJhY2tzW2luZm8ua2V5XSB8fCBbXTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGFuIGV4aXN0aW5nIG1hdGNoIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgICAgICAgX2dldE1hdGNoZXMoaW5mby5rZXksIGluZm8ubW9kaWZpZXJzLCB7dHlwZTogaW5mby5hY3Rpb259LCBzZXF1ZW5jZU5hbWUsIGNvbWJpbmF0aW9uLCBsZXZlbCk7XG5cbiAgICAgICAgICAgIC8vIGFkZCB0aGlzIGNhbGwgYmFjayB0byB0aGUgYXJyYXlcbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIGEgc2VxdWVuY2UgcHV0IGl0IGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICAgIC8vIGlmIG5vdCBwdXQgaXQgYXQgdGhlIGVuZFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIHdheSB0aGVzZSBhcmUgcHJvY2Vzc2VkIGV4cGVjdHNcbiAgICAgICAgICAgIC8vIHRoZSBzZXF1ZW5jZSBvbmVzIHRvIGNvbWUgZmlyc3RcbiAgICAgICAgICAgIHNlbGYuX2NhbGxiYWNrc1tpbmZvLmtleV1bc2VxdWVuY2VOYW1lID8gJ3Vuc2hpZnQnIDogJ3B1c2gnXSh7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyczogaW5mby5tb2RpZmllcnMsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBpbmZvLmFjdGlvbixcbiAgICAgICAgICAgICAgICBzZXE6IHNlcXVlbmNlTmFtZSxcbiAgICAgICAgICAgICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICAgICAgICAgICAgY29tYm86IGNvbWJpbmF0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBiaW5kcyBtdWx0aXBsZSBjb21iaW5hdGlvbnMgdG8gdGhlIHNhbWUgY2FsbGJhY2tcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gY29tYmluYXRpb25zXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gYWN0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuX2JpbmRNdWx0aXBsZSA9IGZ1bmN0aW9uKGNvbWJpbmF0aW9ucywgY2FsbGJhY2ssIGFjdGlvbikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21iaW5hdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBfYmluZFNpbmdsZShjb21iaW5hdGlvbnNbaV0sIGNhbGxiYWNrLCBhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHN0YXJ0IVxuICAgICAgICBfYWRkRXZlbnQodGFyZ2V0RWxlbWVudCwgJ2tleXByZXNzJywgX2hhbmRsZUtleUV2ZW50KTtcbiAgICAgICAgX2FkZEV2ZW50KHRhcmdldEVsZW1lbnQsICdrZXlkb3duJywgX2hhbmRsZUtleUV2ZW50KTtcbiAgICAgICAgX2FkZEV2ZW50KHRhcmdldEVsZW1lbnQsICdrZXl1cCcsIF9oYW5kbGVLZXlFdmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYmluZHMgYW4gZXZlbnQgdG8gbW91c2V0cmFwXG4gICAgICpcbiAgICAgKiBjYW4gYmUgYSBzaW5nbGUga2V5LCBhIGNvbWJpbmF0aW9uIG9mIGtleXMgc2VwYXJhdGVkIHdpdGggKyxcbiAgICAgKiBhbiBhcnJheSBvZiBrZXlzLCBvciBhIHNlcXVlbmNlIG9mIGtleXMgc2VwYXJhdGVkIGJ5IHNwYWNlc1xuICAgICAqXG4gICAgICogYmUgc3VyZSB0byBsaXN0IHRoZSBtb2RpZmllciBrZXlzIGZpcnN0IHRvIG1ha2Ugc3VyZSB0aGF0IHRoZVxuICAgICAqIGNvcnJlY3Qga2V5IGVuZHMgdXAgZ2V0dGluZyBib3VuZCAodGhlIGxhc3Qga2V5IGluIHRoZSBwYXR0ZXJuKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IGtleXNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYWN0aW9uIC0gJ2tleXByZXNzJywgJ2tleWRvd24nLCBvciAna2V5dXAnXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIE1vdXNldHJhcC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGtleXMsIGNhbGxiYWNrLCBhY3Rpb24pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBrZXlzID0ga2V5cyBpbnN0YW5jZW9mIEFycmF5ID8ga2V5cyA6IFtrZXlzXTtcbiAgICAgICAgc2VsZi5fYmluZE11bHRpcGxlLmNhbGwoc2VsZiwga2V5cywgY2FsbGJhY2ssIGFjdGlvbik7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB1bmJpbmRzIGFuIGV2ZW50IHRvIG1vdXNldHJhcFxuICAgICAqXG4gICAgICogdGhlIHVuYmluZGluZyBzZXRzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBvZiB0aGUgc3BlY2lmaWVkIGtleSBjb21ib1xuICAgICAqIHRvIGFuIGVtcHR5IGZ1bmN0aW9uIGFuZCBkZWxldGVzIHRoZSBjb3JyZXNwb25kaW5nIGtleSBpbiB0aGVcbiAgICAgKiBfZGlyZWN0TWFwIGRpY3QuXG4gICAgICpcbiAgICAgKiBUT0RPOiBhY3R1YWxseSByZW1vdmUgdGhpcyBmcm9tIHRoZSBfY2FsbGJhY2tzIGRpY3Rpb25hcnkgaW5zdGVhZFxuICAgICAqIG9mIGJpbmRpbmcgYW4gZW1wdHkgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIHRoZSBrZXljb21ibythY3Rpb24gaGFzIHRvIGJlIGV4YWN0bHkgdGhlIHNhbWUgYXNcbiAgICAgKiBpdCB3YXMgZGVmaW5lZCBpbiB0aGUgYmluZCBtZXRob2RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBrZXlzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvblxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBNb3VzZXRyYXAucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uKGtleXMsIGFjdGlvbikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBzZWxmLmJpbmQuY2FsbChzZWxmLCBrZXlzLCBmdW5jdGlvbigpIHt9LCBhY3Rpb24pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB0cmlnZ2VycyBhbiBldmVudCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gYm91bmRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlzXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBhY3Rpb25cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgTW91c2V0cmFwLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24oa2V5cywgYWN0aW9uKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHNlbGYuX2RpcmVjdE1hcFtrZXlzICsgJzonICsgYWN0aW9uXSkge1xuICAgICAgICAgICAgc2VsZi5fZGlyZWN0TWFwW2tleXMgKyAnOicgKyBhY3Rpb25dKHt9LCBrZXlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogcmVzZXRzIHRoZSBsaWJyYXJ5IGJhY2sgdG8gaXRzIGluaXRpYWwgc3RhdGUuICB0aGlzIGlzIHVzZWZ1bFxuICAgICAqIGlmIHlvdSB3YW50IHRvIGNsZWFyIG91dCB0aGUgY3VycmVudCBrZXlib2FyZCBzaG9ydGN1dHMgYW5kIGJpbmRcbiAgICAgKiBuZXcgb25lcyAtIGZvciBleGFtcGxlIGlmIHlvdSBzd2l0Y2ggdG8gYW5vdGhlciBwYWdlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgTW91c2V0cmFwLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHNlbGYuX2NhbGxiYWNrcyA9IHt9O1xuICAgICAgICBzZWxmLl9kaXJlY3RNYXAgPSB7fTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNob3VsZCB3ZSBzdG9wIHRoaXMgZXZlbnQgYmVmb3JlIGZpcmluZyBvZmYgY2FsbGJhY2tzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBNb3VzZXRyYXAucHJvdG90eXBlLnN0b3BDYWxsYmFjayA9IGZ1bmN0aW9uKGUsIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGhhcyB0aGUgY2xhc3MgXCJtb3VzZXRyYXBcIiB0aGVuIG5vIG5lZWQgdG8gc3RvcFxuICAgICAgICBpZiAoKCcgJyArIGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnKS5pbmRleE9mKCcgbW91c2V0cmFwICcpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfYmVsb25nc1RvKGVsZW1lbnQsIHNlbGYudGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcCBmb3IgaW5wdXQsIHNlbGVjdCwgYW5kIHRleHRhcmVhXG4gICAgICAgIHJldHVybiBlbGVtZW50LnRhZ05hbWUgPT0gJ0lOUFVUJyB8fCBlbGVtZW50LnRhZ05hbWUgPT0gJ1NFTEVDVCcgfHwgZWxlbWVudC50YWdOYW1lID09ICdURVhUQVJFQScgfHwgZWxlbWVudC5pc0NvbnRlbnRFZGl0YWJsZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogZXhwb3NlcyBfaGFuZGxlS2V5IHB1YmxpY2x5IHNvIGl0IGNhbiBiZSBvdmVyd3JpdHRlbiBieSBleHRlbnNpb25zXG4gICAgICovXG4gICAgTW91c2V0cmFwLnByb3RvdHlwZS5oYW5kbGVLZXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gc2VsZi5faGFuZGxlS2V5LmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGFsbG93IGN1c3RvbSBrZXkgbWFwcGluZ3NcbiAgICAgKi9cbiAgICBNb3VzZXRyYXAuYWRkS2V5Y29kZXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgX01BUFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX1JFVkVSU0VfTUFQID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5pdCB0aGUgZ2xvYmFsIG1vdXNldHJhcCBmdW5jdGlvbnNcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5lZWRlZCB0byBhbGxvdyB0aGUgZ2xvYmFsIG1vdXNldHJhcCBmdW5jdGlvbnMgdG8gd29ya1xuICAgICAqIG5vdyB0aGF0IG1vdXNldHJhcCBpcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIE1vdXNldHJhcC5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkb2N1bWVudE1vdXNldHJhcCA9IE1vdXNldHJhcChkb2N1bWVudCk7XG4gICAgICAgIGZvciAodmFyIG1ldGhvZCBpbiBkb2N1bWVudE1vdXNldHJhcCkge1xuICAgICAgICAgICAgaWYgKG1ldGhvZC5jaGFyQXQoMCkgIT09ICdfJykge1xuICAgICAgICAgICAgICAgIE1vdXNldHJhcFttZXRob2RdID0gKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnRNb3VzZXRyYXBbbWV0aG9kXS5hcHBseShkb2N1bWVudE1vdXNldHJhcCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IChtZXRob2QpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBNb3VzZXRyYXAuaW5pdCgpO1xuXG4gICAgLy8gZXhwb3NlIG1vdXNldHJhcCB0byB0aGUgZ2xvYmFsIG9iamVjdFxuICAgIHdpbmRvdy5Nb3VzZXRyYXAgPSBNb3VzZXRyYXA7XG5cbiAgICAvLyBleHBvc2UgYXMgYSBjb21tb24ganMgbW9kdWxlXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gTW91c2V0cmFwO1xuICAgIH1cblxuICAgIC8vIGV4cG9zZSBtb3VzZXRyYXAgYXMgYW4gQU1EIG1vZHVsZVxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1vdXNldHJhcDtcbiAgICAgICAgfSk7XG4gICAgfVxufSkgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogbnVsbCwgdHlwZW9mICB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiBudWxsKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mousetrap/mousetrap.js\n");

/***/ })

}]);
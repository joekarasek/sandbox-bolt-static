(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~bolt-copy-to-clipboard"],{

/***/ "./node_modules/@bolt/components-copy-to-clipboard/src/copy-to-clipboard.standalone.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@bolt/components-copy-to-clipboard/src/copy-to-clipboard.standalone.js ***!
  \*********************************************************************************************/
/*! exports provided: BoltCopyToClipboard */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoltCopyToClipboard\", function() { return BoltCopyToClipboard; });\n/* harmony import */ var clipboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clipboard */ \"./node_modules/clipboard/dist/clipboard.js\");\n/* harmony import */ var clipboard__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(clipboard__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _bolt_core_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bolt/core/utils */ \"./node_modules/@bolt/core/utils/index.js\");\n/* harmony import */ var _bolt_core_renderers_renderer_lit_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @bolt/core/renderers/renderer-lit-html */ \"./node_modules/@bolt/core/renderers/renderer-lit-html.js\");\nvar _class, _class2, _temp;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n      \", \"\\n    \"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\nvar BoltCopyToClipboard = Object(_bolt_core_utils__WEBPACK_IMPORTED_MODULE_1__[\"define\"])(_class = (_temp = _class2 =\n/*#__PURE__*/\nfunction (_withLitHtml) {\n  _inherits(BoltCopyToClipboard, _withLitHtml);\n\n  function BoltCopyToClipboard(self) {\n    var _this;\n\n    _classCallCheck(this, BoltCopyToClipboard);\n\n    self = _this = _possibleConstructorReturn(this, _getPrototypeOf(BoltCopyToClipboard).call(this, self));\n    _this.useShadow = false;\n    return _possibleConstructorReturn(_this, self);\n  }\n\n  _createClass(BoltCopyToClipboard, [{\n    key: \"connecting\",\n    value: function connecting() {\n      var _this2 = this;\n\n      this.copyTrigger = this.querySelector('[data-clipboard-text]');\n      this.parentElem = this.querySelector('.js-bolt-copy-to-clipboard');\n      this.clipboardInstance = new clipboard__WEBPACK_IMPORTED_MODULE_0___default.a(this.copyTrigger);\n      this.clipboardInstance.on('success', function () {\n        // Copying is already successful at this point.  Everything from here on is UX flair.\n        // Show the \"in progress\" status.\n        _this2.parentElem.classList.add('is-animating'); // Show the \"success\" status.\n\n\n        setTimeout(function () {\n          _this2.parentElem.classList.add('is-successful'); // Reset so the link can be used again without refreshing the page.\n\n\n          setTimeout(function () {\n            _this2.parentElem.classList.remove('is-successful');\n\n            _this2.parentElem.classList.remove('is-animating');\n          }, 3000);\n        }, 1000);\n      });\n    }\n  }, {\n    key: \"disconnecting\",\n    value: function disconnecting() {\n      this.clipboardInstance.destroy();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return Object(_bolt_core_renderers_renderer_lit_html__WEBPACK_IMPORTED_MODULE_2__[\"html\"])(_templateObject(), this.slot('default'));\n    }\n  }]);\n\n  return BoltCopyToClipboard;\n}(Object(_bolt_core_renderers_renderer_lit_html__WEBPACK_IMPORTED_MODULE_2__[\"withLitHtml\"])()), _class2.is = 'bolt-copy-to-clipboard', _temp)) || _class;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJvbHQvY29tcG9uZW50cy1jb3B5LXRvLWNsaXBib2FyZC9zcmMvY29weS10by1jbGlwYm9hcmQuc3RhbmRhbG9uZS5qcz84M2E5Il0sIm5hbWVzIjpbIkJvbHRDb3B5VG9DbGlwYm9hcmQiLCJkZWZpbmUiLCJzZWxmIiwidXNlU2hhZG93IiwiY29weVRyaWdnZXIiLCJxdWVyeVNlbGVjdG9yIiwicGFyZW50RWxlbSIsImNsaXBib2FyZEluc3RhbmNlIiwiQ2xpcGJvYXJkSlMiLCJvbiIsImNsYXNzTGlzdCIsImFkZCIsInNldFRpbWVvdXQiLCJyZW1vdmUiLCJkZXN0cm95IiwiaHRtbCIsInNsb3QiLCJ3aXRoTGl0SHRtbCIsImlzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBRUE7QUFDQTs7SUFHTUEsbUIsR0FETEMsK0Q7Ozs7O0FBSUMsK0JBQVlDLElBQVosRUFBa0I7QUFBQTs7QUFBQTs7QUFDaEJBLFFBQUksNEZBQVNBLElBQVQsRUFBSjtBQUNBLFVBQUtDLFNBQUwsR0FBaUIsS0FBakI7QUFDQSw2Q0FBT0QsSUFBUDtBQUNEOzs7O2lDQUVZO0FBQUE7O0FBQ1gsV0FBS0UsV0FBTCxHQUFtQixLQUFLQyxhQUFMLENBQW1CLHVCQUFuQixDQUFuQjtBQUNBLFdBQUtDLFVBQUwsR0FBa0IsS0FBS0QsYUFBTCxDQUFtQiw0QkFBbkIsQ0FBbEI7QUFFQSxXQUFLRSxpQkFBTCxHQUF5QixJQUFJQyxnREFBSixDQUFnQixLQUFLSixXQUFyQixDQUF6QjtBQUVBLFdBQUtHLGlCQUFMLENBQXVCRSxFQUF2QixDQUEwQixTQUExQixFQUFxQyxZQUFNO0FBQ3pDO0FBRUE7QUFDQSxjQUFJLENBQUNILFVBQUwsQ0FBZ0JJLFNBQWhCLENBQTBCQyxHQUExQixDQUE4QixjQUE5QixFQUp5QyxDQU16Qzs7O0FBQ0FDLGtCQUFVLENBQUMsWUFBTTtBQUNmLGdCQUFJLENBQUNOLFVBQUwsQ0FBZ0JJLFNBQWhCLENBQTBCQyxHQUExQixDQUE4QixlQUE5QixFQURlLENBR2Y7OztBQUNBQyxvQkFBVSxDQUFDLFlBQU07QUFDZixrQkFBSSxDQUFDTixVQUFMLENBQWdCSSxTQUFoQixDQUEwQkcsTUFBMUIsQ0FBaUMsZUFBakM7O0FBQ0Esa0JBQUksQ0FBQ1AsVUFBTCxDQUFnQkksU0FBaEIsQ0FBMEJHLE1BQTFCLENBQWlDLGNBQWpDO0FBQ0QsV0FIUyxFQUdQLElBSE8sQ0FBVjtBQUlELFNBUlMsRUFRUCxJQVJPLENBQVY7QUFTRCxPQWhCRDtBQWlCRDs7O29DQUVlO0FBQ2QsV0FBS04saUJBQUwsQ0FBdUJPLE9BQXZCO0FBQ0Q7Ozs2QkFFUTtBQUNQLGFBQU9DLG1GQUFQLG9CQUNJLEtBQUtDLElBQUwsQ0FBVSxTQUFWLENBREo7QUFHRDs7OztFQTFDK0JDLDBGQUFXLEUsV0FDcENDLEUsR0FBSyx3QiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AYm9sdC9jb21wb25lbnRzLWNvcHktdG8tY2xpcGJvYXJkL3NyYy9jb3B5LXRvLWNsaXBib2FyZC5zdGFuZGFsb25lLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENsaXBib2FyZEpTIGZyb20gJ2NsaXBib2FyZCc7XG5cbmltcG9ydCB7IHByb3BzLCBkZWZpbmUgfSBmcm9tICdAYm9sdC9jb3JlL3V0aWxzJztcbmltcG9ydCB7IHdpdGhMaXRIdG1sLCBodG1sIH0gZnJvbSAnQGJvbHQvY29yZS9yZW5kZXJlcnMvcmVuZGVyZXItbGl0LWh0bWwnO1xuXG5AZGVmaW5lXG5jbGFzcyBCb2x0Q29weVRvQ2xpcGJvYXJkIGV4dGVuZHMgd2l0aExpdEh0bWwoKSB7XG4gIHN0YXRpYyBpcyA9ICdib2x0LWNvcHktdG8tY2xpcGJvYXJkJztcblxuICBjb25zdHJ1Y3RvcihzZWxmKSB7XG4gICAgc2VsZiA9IHN1cGVyKHNlbGYpO1xuICAgIHRoaXMudXNlU2hhZG93ID0gZmFsc2U7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICBjb25uZWN0aW5nKCkge1xuICAgIHRoaXMuY29weVRyaWdnZXIgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWNsaXBib2FyZC10ZXh0XScpO1xuICAgIHRoaXMucGFyZW50RWxlbSA9IHRoaXMucXVlcnlTZWxlY3RvcignLmpzLWJvbHQtY29weS10by1jbGlwYm9hcmQnKTtcblxuICAgIHRoaXMuY2xpcGJvYXJkSW5zdGFuY2UgPSBuZXcgQ2xpcGJvYXJkSlModGhpcy5jb3B5VHJpZ2dlcik7XG5cbiAgICB0aGlzLmNsaXBib2FyZEluc3RhbmNlLm9uKCdzdWNjZXNzJywgKCkgPT4ge1xuICAgICAgLy8gQ29weWluZyBpcyBhbHJlYWR5IHN1Y2Nlc3NmdWwgYXQgdGhpcyBwb2ludC4gIEV2ZXJ5dGhpbmcgZnJvbSBoZXJlIG9uIGlzIFVYIGZsYWlyLlxuXG4gICAgICAvLyBTaG93IHRoZSBcImluIHByb2dyZXNzXCIgc3RhdHVzLlxuICAgICAgdGhpcy5wYXJlbnRFbGVtLmNsYXNzTGlzdC5hZGQoJ2lzLWFuaW1hdGluZycpO1xuXG4gICAgICAvLyBTaG93IHRoZSBcInN1Y2Nlc3NcIiBzdGF0dXMuXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5wYXJlbnRFbGVtLmNsYXNzTGlzdC5hZGQoJ2lzLXN1Y2Nlc3NmdWwnKTtcblxuICAgICAgICAvLyBSZXNldCBzbyB0aGUgbGluayBjYW4gYmUgdXNlZCBhZ2FpbiB3aXRob3V0IHJlZnJlc2hpbmcgdGhlIHBhZ2UuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMucGFyZW50RWxlbS5jbGFzc0xpc3QucmVtb3ZlKCdpcy1zdWNjZXNzZnVsJyk7XG4gICAgICAgICAgdGhpcy5wYXJlbnRFbGVtLmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWFuaW1hdGluZycpO1xuICAgICAgICB9LCAzMDAwKTtcbiAgICAgIH0sIDEwMDApO1xuICAgIH0pO1xuICB9XG5cbiAgZGlzY29ubmVjdGluZygpIHtcbiAgICB0aGlzLmNsaXBib2FyZEluc3RhbmNlLmRlc3Ryb3koKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gaHRtbGBcbiAgICAgICR7dGhpcy5zbG90KCdkZWZhdWx0Jyl9XG4gICAgYDtcbiAgfVxufVxuXG5leHBvcnQgeyBCb2x0Q29weVRvQ2xpcGJvYXJkIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@bolt/components-copy-to-clipboard/src/copy-to-clipboard.standalone.js\n");

/***/ }),

/***/ "./node_modules/clipboard/dist/clipboard.js":
/*!**************************************************!*\
  !*** ./node_modules/clipboard/dist/clipboard.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof2(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\n/*!\n * clipboard.js v2.0.4\n * https://zenorocha.github.io/clipboard.js\n * \n * Licensed MIT © Zeno Rocha\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (( false ? undefined : _typeof2(exports)) === 'object' && ( false ? undefined : _typeof2(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}\n})(this, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            enumerable: true,\n            get: getter\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // define __esModule on exports\n\n      /******/\n\n\n      __webpack_require__.r = function (exports) {\n        /******/\n        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n          /******/\n          Object.defineProperty(exports, Symbol.toStringTag, {\n            value: 'Module'\n          });\n          /******/\n        }\n        /******/\n\n\n        Object.defineProperty(exports, '__esModule', {\n          value: true\n        });\n        /******/\n      };\n      /******/\n\n      /******/\n      // create a fake namespace object\n\n      /******/\n      // mode & 1: value is a module id, require it\n\n      /******/\n      // mode & 2: merge all properties of value into the ns\n\n      /******/\n      // mode & 4: return value when already ns object\n\n      /******/\n      // mode & 8|1: behave like require\n\n      /******/\n\n\n      __webpack_require__.t = function (value, mode) {\n        /******/\n        if (mode & 1) value = __webpack_require__(value);\n        /******/\n\n        if (mode & 8) return value;\n        /******/\n\n        if (mode & 4 && _typeof2(value) === 'object' && value && value.__esModule) return value;\n        /******/\n\n        var ns = Object.create(null);\n        /******/\n\n        __webpack_require__.r(ns);\n        /******/\n\n\n        Object.defineProperty(ns, 'default', {\n          enumerable: true,\n          value: value\n        });\n        /******/\n\n        if (mode & 2 && typeof value != 'string') for (var key in value) {\n          __webpack_require__.d(ns, key, function (key) {\n            return value[key];\n          }.bind(null, key));\n        }\n        /******/\n\n        return ns;\n        /******/\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = 0);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n        return _typeof2(obj);\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n      };\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _clipboardAction = __webpack_require__(1);\n\n      var _clipboardAction2 = _interopRequireDefault(_clipboardAction);\n\n      var _tinyEmitter = __webpack_require__(3);\n\n      var _tinyEmitter2 = _interopRequireDefault(_tinyEmitter);\n\n      var _goodListener = __webpack_require__(4);\n\n      var _goodListener2 = _interopRequireDefault(_goodListener);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof2(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof2(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n      /**\n       * Base class which takes one or more elements, adds event listeners to them,\n       * and instantiates a new `ClipboardAction` on each click.\n       */\n\n\n      var Clipboard = function (_Emitter) {\n        _inherits(Clipboard, _Emitter);\n        /**\n         * @param {String|HTMLElement|HTMLCollection|NodeList} trigger\n         * @param {Object} options\n         */\n\n\n        function Clipboard(trigger, options) {\n          _classCallCheck(this, Clipboard);\n\n          var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this));\n\n          _this.resolveOptions(options);\n\n          _this.listenClick(trigger);\n\n          return _this;\n        }\n        /**\n         * Defines if attributes would be resolved using internal setter functions\n         * or custom functions that were passed in the constructor.\n         * @param {Object} options\n         */\n\n\n        _createClass(Clipboard, [{\n          key: 'resolveOptions',\n          value: function resolveOptions() {\n            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            this.action = typeof options.action === 'function' ? options.action : this.defaultAction;\n            this.target = typeof options.target === 'function' ? options.target : this.defaultTarget;\n            this.text = typeof options.text === 'function' ? options.text : this.defaultText;\n            this.container = _typeof(options.container) === 'object' ? options.container : document.body;\n          }\n          /**\n           * Adds a click event listener to the passed trigger.\n           * @param {String|HTMLElement|HTMLCollection|NodeList} trigger\n           */\n\n        }, {\n          key: 'listenClick',\n          value: function listenClick(trigger) {\n            var _this2 = this;\n\n            this.listener = (0, _goodListener2.default)(trigger, 'click', function (e) {\n              return _this2.onClick(e);\n            });\n          }\n          /**\n           * Defines a new `ClipboardAction` on each click event.\n           * @param {Event} e\n           */\n\n        }, {\n          key: 'onClick',\n          value: function onClick(e) {\n            var trigger = e.delegateTarget || e.currentTarget;\n\n            if (this.clipboardAction) {\n              this.clipboardAction = null;\n            }\n\n            this.clipboardAction = new _clipboardAction2.default({\n              action: this.action(trigger),\n              target: this.target(trigger),\n              text: this.text(trigger),\n              container: this.container,\n              trigger: trigger,\n              emitter: this\n            });\n          }\n          /**\n           * Default `action` lookup function.\n           * @param {Element} trigger\n           */\n\n        }, {\n          key: 'defaultAction',\n          value: function defaultAction(trigger) {\n            return getAttributeValue('action', trigger);\n          }\n          /**\n           * Default `target` lookup function.\n           * @param {Element} trigger\n           */\n\n        }, {\n          key: 'defaultTarget',\n          value: function defaultTarget(trigger) {\n            var selector = getAttributeValue('target', trigger);\n\n            if (selector) {\n              return document.querySelector(selector);\n            }\n          }\n          /**\n           * Returns the support of the given action, or all actions if no action is\n           * given.\n           * @param {String} [action]\n           */\n\n        }, {\n          key: 'defaultText',\n\n          /**\n           * Default `text` lookup function.\n           * @param {Element} trigger\n           */\n          value: function defaultText(trigger) {\n            return getAttributeValue('text', trigger);\n          }\n          /**\n           * Destroy lifecycle.\n           */\n\n        }, {\n          key: 'destroy',\n          value: function destroy() {\n            this.listener.destroy();\n\n            if (this.clipboardAction) {\n              this.clipboardAction.destroy();\n              this.clipboardAction = null;\n            }\n          }\n        }], [{\n          key: 'isSupported',\n          value: function isSupported() {\n            var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['copy', 'cut'];\n            var actions = typeof action === 'string' ? [action] : action;\n            var support = !!document.queryCommandSupported;\n            actions.forEach(function (action) {\n              support = support && !!document.queryCommandSupported(action);\n            });\n            return support;\n          }\n        }]);\n\n        return Clipboard;\n      }(_tinyEmitter2.default);\n      /**\n       * Helper function to retrieve attribute value.\n       * @param {String} suffix\n       * @param {Element} element\n       */\n\n\n      function getAttributeValue(suffix, element) {\n        var attribute = 'data-clipboard-' + suffix;\n\n        if (!element.hasAttribute(attribute)) {\n          return;\n        }\n\n        return element.getAttribute(attribute);\n      }\n\n      module.exports = Clipboard;\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n        return _typeof2(obj);\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n      };\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _select = __webpack_require__(2);\n\n      var _select2 = _interopRequireDefault(_select);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      /**\n       * Inner class which performs selection from either `text` or `target`\n       * properties and then executes copy or cut operations.\n       */\n\n\n      var ClipboardAction = function () {\n        /**\n         * @param {Object} options\n         */\n        function ClipboardAction(options) {\n          _classCallCheck(this, ClipboardAction);\n\n          this.resolveOptions(options);\n          this.initSelection();\n        }\n        /**\n         * Defines base properties passed from constructor.\n         * @param {Object} options\n         */\n\n\n        _createClass(ClipboardAction, [{\n          key: 'resolveOptions',\n          value: function resolveOptions() {\n            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            this.action = options.action;\n            this.container = options.container;\n            this.emitter = options.emitter;\n            this.target = options.target;\n            this.text = options.text;\n            this.trigger = options.trigger;\n            this.selectedText = '';\n          }\n          /**\n           * Decides which selection strategy is going to be applied based\n           * on the existence of `text` and `target` properties.\n           */\n\n        }, {\n          key: 'initSelection',\n          value: function initSelection() {\n            if (this.text) {\n              this.selectFake();\n            } else if (this.target) {\n              this.selectTarget();\n            }\n          }\n          /**\n           * Creates a fake textarea element, sets its value from `text` property,\n           * and makes a selection on it.\n           */\n\n        }, {\n          key: 'selectFake',\n          value: function selectFake() {\n            var _this = this;\n\n            var isRTL = document.documentElement.getAttribute('dir') == 'rtl';\n            this.removeFake();\n\n            this.fakeHandlerCallback = function () {\n              return _this.removeFake();\n            };\n\n            this.fakeHandler = this.container.addEventListener('click', this.fakeHandlerCallback) || true;\n            this.fakeElem = document.createElement('textarea'); // Prevent zooming on iOS\n\n            this.fakeElem.style.fontSize = '12pt'; // Reset box model\n\n            this.fakeElem.style.border = '0';\n            this.fakeElem.style.padding = '0';\n            this.fakeElem.style.margin = '0'; // Move element out of screen horizontally\n\n            this.fakeElem.style.position = 'absolute';\n            this.fakeElem.style[isRTL ? 'right' : 'left'] = '-9999px'; // Move element to the same position vertically\n\n            var yPosition = window.pageYOffset || document.documentElement.scrollTop;\n            this.fakeElem.style.top = yPosition + 'px';\n            this.fakeElem.setAttribute('readonly', '');\n            this.fakeElem.value = this.text;\n            this.container.appendChild(this.fakeElem);\n            this.selectedText = (0, _select2.default)(this.fakeElem);\n            this.copyText();\n          }\n          /**\n           * Only removes the fake element after another click event, that way\n           * a user can hit `Ctrl+C` to copy because selection still exists.\n           */\n\n        }, {\n          key: 'removeFake',\n          value: function removeFake() {\n            if (this.fakeHandler) {\n              this.container.removeEventListener('click', this.fakeHandlerCallback);\n              this.fakeHandler = null;\n              this.fakeHandlerCallback = null;\n            }\n\n            if (this.fakeElem) {\n              this.container.removeChild(this.fakeElem);\n              this.fakeElem = null;\n            }\n          }\n          /**\n           * Selects the content from element passed on `target` property.\n           */\n\n        }, {\n          key: 'selectTarget',\n          value: function selectTarget() {\n            this.selectedText = (0, _select2.default)(this.target);\n            this.copyText();\n          }\n          /**\n           * Executes the copy operation based on the current selection.\n           */\n\n        }, {\n          key: 'copyText',\n          value: function copyText() {\n            var succeeded = void 0;\n\n            try {\n              succeeded = document.execCommand(this.action);\n            } catch (err) {\n              succeeded = false;\n            }\n\n            this.handleResult(succeeded);\n          }\n          /**\n           * Fires an event based on the copy operation result.\n           * @param {Boolean} succeeded\n           */\n\n        }, {\n          key: 'handleResult',\n          value: function handleResult(succeeded) {\n            this.emitter.emit(succeeded ? 'success' : 'error', {\n              action: this.action,\n              text: this.selectedText,\n              trigger: this.trigger,\n              clearSelection: this.clearSelection.bind(this)\n            });\n          }\n          /**\n           * Moves focus away from `target` and back to the trigger, removes current selection.\n           */\n\n        }, {\n          key: 'clearSelection',\n          value: function clearSelection() {\n            if (this.trigger) {\n              this.trigger.focus();\n            }\n\n            window.getSelection().removeAllRanges();\n          }\n          /**\n           * Sets the `action` to be performed which can be either 'copy' or 'cut'.\n           * @param {String} action\n           */\n\n        }, {\n          key: 'destroy',\n\n          /**\n           * Destroy lifecycle.\n           */\n          value: function destroy() {\n            this.removeFake();\n          }\n        }, {\n          key: 'action',\n          set: function set() {\n            var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'copy';\n            this._action = action;\n\n            if (this._action !== 'copy' && this._action !== 'cut') {\n              throw new Error('Invalid \"action\" value, use either \"copy\" or \"cut\"');\n            }\n          }\n          /**\n           * Gets the `action` property.\n           * @return {String}\n           */\n          ,\n          get: function get() {\n            return this._action;\n          }\n          /**\n           * Sets the `target` property using an element\n           * that will be have its content copied.\n           * @param {Element} target\n           */\n\n        }, {\n          key: 'target',\n          set: function set(target) {\n            if (target !== undefined) {\n              if (target && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && target.nodeType === 1) {\n                if (this.action === 'copy' && target.hasAttribute('disabled')) {\n                  throw new Error('Invalid \"target\" attribute. Please use \"readonly\" instead of \"disabled\" attribute');\n                }\n\n                if (this.action === 'cut' && (target.hasAttribute('readonly') || target.hasAttribute('disabled'))) {\n                  throw new Error('Invalid \"target\" attribute. You can\\'t cut text from elements with \"readonly\" or \"disabled\" attributes');\n                }\n\n                this._target = target;\n              } else {\n                throw new Error('Invalid \"target\" value, use a valid Element');\n              }\n            }\n          }\n          /**\n           * Gets the `target` property.\n           * @return {String|HTMLElement}\n           */\n          ,\n          get: function get() {\n            return this._target;\n          }\n        }]);\n\n        return ClipboardAction;\n      }();\n\n      module.exports = ClipboardAction;\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports) {\n      function select(element) {\n        var selectedText;\n\n        if (element.nodeName === 'SELECT') {\n          element.focus();\n          selectedText = element.value;\n        } else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {\n          var isReadOnly = element.hasAttribute('readonly');\n\n          if (!isReadOnly) {\n            element.setAttribute('readonly', '');\n          }\n\n          element.select();\n          element.setSelectionRange(0, element.value.length);\n\n          if (!isReadOnly) {\n            element.removeAttribute('readonly');\n          }\n\n          selectedText = element.value;\n        } else {\n          if (element.hasAttribute('contenteditable')) {\n            element.focus();\n          }\n\n          var selection = window.getSelection();\n          var range = document.createRange();\n          range.selectNodeContents(element);\n          selection.removeAllRanges();\n          selection.addRange(range);\n          selectedText = selection.toString();\n        }\n\n        return selectedText;\n      }\n\n      module.exports = select;\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports) {\n      function E() {// Keep this empty so it's easier to inherit from\n        // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\n      }\n\n      E.prototype = {\n        on: function on(name, callback, ctx) {\n          var e = this.e || (this.e = {});\n          (e[name] || (e[name] = [])).push({\n            fn: callback,\n            ctx: ctx\n          });\n          return this;\n        },\n        once: function once(name, callback, ctx) {\n          var self = this;\n\n          function listener() {\n            self.off(name, listener);\n            callback.apply(ctx, arguments);\n          }\n\n          ;\n          listener._ = callback;\n          return this.on(name, listener, ctx);\n        },\n        emit: function emit(name) {\n          var data = [].slice.call(arguments, 1);\n          var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\n          var i = 0;\n          var len = evtArr.length;\n\n          for (i; i < len; i++) {\n            evtArr[i].fn.apply(evtArr[i].ctx, data);\n          }\n\n          return this;\n        },\n        off: function off(name, callback) {\n          var e = this.e || (this.e = {});\n          var evts = e[name];\n          var liveEvents = [];\n\n          if (evts && callback) {\n            for (var i = 0, len = evts.length; i < len; i++) {\n              if (evts[i].fn !== callback && evts[i].fn._ !== callback) liveEvents.push(evts[i]);\n            }\n          } // Remove event from queue to prevent memory leak\n          // Suggested by https://github.com/lazd\n          // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910\n\n\n          liveEvents.length ? e[name] = liveEvents : delete e[name];\n          return this;\n        }\n      };\n      module.exports = E;\n      /***/\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      var is = __webpack_require__(5);\n\n      var delegate = __webpack_require__(6);\n      /**\n       * Validates all params and calls the right\n       * listener function based on its target type.\n       *\n       * @param {String|HTMLElement|HTMLCollection|NodeList} target\n       * @param {String} type\n       * @param {Function} callback\n       * @return {Object}\n       */\n\n\n      function listen(target, type, callback) {\n        if (!target && !type && !callback) {\n          throw new Error('Missing required arguments');\n        }\n\n        if (!is.string(type)) {\n          throw new TypeError('Second argument must be a String');\n        }\n\n        if (!is.fn(callback)) {\n          throw new TypeError('Third argument must be a Function');\n        }\n\n        if (is.node(target)) {\n          return listenNode(target, type, callback);\n        } else if (is.nodeList(target)) {\n          return listenNodeList(target, type, callback);\n        } else if (is.string(target)) {\n          return listenSelector(target, type, callback);\n        } else {\n          throw new TypeError('First argument must be a String, HTMLElement, HTMLCollection, or NodeList');\n        }\n      }\n      /**\n       * Adds an event listener to a HTML element\n       * and returns a remove listener function.\n       *\n       * @param {HTMLElement} node\n       * @param {String} type\n       * @param {Function} callback\n       * @return {Object}\n       */\n\n\n      function listenNode(node, type, callback) {\n        node.addEventListener(type, callback);\n        return {\n          destroy: function destroy() {\n            node.removeEventListener(type, callback);\n          }\n        };\n      }\n      /**\n       * Add an event listener to a list of HTML elements\n       * and returns a remove listener function.\n       *\n       * @param {NodeList|HTMLCollection} nodeList\n       * @param {String} type\n       * @param {Function} callback\n       * @return {Object}\n       */\n\n\n      function listenNodeList(nodeList, type, callback) {\n        Array.prototype.forEach.call(nodeList, function (node) {\n          node.addEventListener(type, callback);\n        });\n        return {\n          destroy: function destroy() {\n            Array.prototype.forEach.call(nodeList, function (node) {\n              node.removeEventListener(type, callback);\n            });\n          }\n        };\n      }\n      /**\n       * Add an event listener to a selector\n       * and returns a remove listener function.\n       *\n       * @param {String} selector\n       * @param {String} type\n       * @param {Function} callback\n       * @return {Object}\n       */\n\n\n      function listenSelector(selector, type, callback) {\n        return delegate(document.body, selector, type, callback);\n      }\n\n      module.exports = listen;\n      /***/\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports) {\n      /**\n       * Check if argument is a HTML element.\n       *\n       * @param {Object} value\n       * @return {Boolean}\n       */\n      exports.node = function (value) {\n        return value !== undefined && value instanceof HTMLElement && value.nodeType === 1;\n      };\n      /**\n       * Check if argument is a list of HTML elements.\n       *\n       * @param {Object} value\n       * @return {Boolean}\n       */\n\n\n      exports.nodeList = function (value) {\n        var type = Object.prototype.toString.call(value);\n        return value !== undefined && (type === '[object NodeList]' || type === '[object HTMLCollection]') && 'length' in value && (value.length === 0 || exports.node(value[0]));\n      };\n      /**\n       * Check if argument is a string.\n       *\n       * @param {Object} value\n       * @return {Boolean}\n       */\n\n\n      exports.string = function (value) {\n        return typeof value === 'string' || value instanceof String;\n      };\n      /**\n       * Check if argument is a function.\n       *\n       * @param {Object} value\n       * @return {Boolean}\n       */\n\n\n      exports.fn = function (value) {\n        var type = Object.prototype.toString.call(value);\n        return type === '[object Function]';\n      };\n      /***/\n\n    },\n    /* 6 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      var closest = __webpack_require__(7);\n      /**\n       * Delegates event to a selector.\n       *\n       * @param {Element} element\n       * @param {String} selector\n       * @param {String} type\n       * @param {Function} callback\n       * @param {Boolean} useCapture\n       * @return {Object}\n       */\n\n\n      function _delegate(element, selector, type, callback, useCapture) {\n        var listenerFn = listener.apply(this, arguments);\n        element.addEventListener(type, listenerFn, useCapture);\n        return {\n          destroy: function destroy() {\n            element.removeEventListener(type, listenerFn, useCapture);\n          }\n        };\n      }\n      /**\n       * Delegates event to a selector.\n       *\n       * @param {Element|String|Array} [elements]\n       * @param {String} selector\n       * @param {String} type\n       * @param {Function} callback\n       * @param {Boolean} useCapture\n       * @return {Object}\n       */\n\n\n      function delegate(elements, selector, type, callback, useCapture) {\n        // Handle the regular Element usage\n        if (typeof elements.addEventListener === 'function') {\n          return _delegate.apply(null, arguments);\n        } // Handle Element-less usage, it defaults to global delegation\n\n\n        if (typeof type === 'function') {\n          // Use `document` as the first parameter, then apply arguments\n          // This is a short way to .unshift `arguments` without running into deoptimizations\n          return _delegate.bind(null, document).apply(null, arguments);\n        } // Handle Selector-based usage\n\n\n        if (typeof elements === 'string') {\n          elements = document.querySelectorAll(elements);\n        } // Handle Array-like based usage\n\n\n        return Array.prototype.map.call(elements, function (element) {\n          return _delegate(element, selector, type, callback, useCapture);\n        });\n      }\n      /**\n       * Finds closest match and invokes callback.\n       *\n       * @param {Element} element\n       * @param {String} selector\n       * @param {String} type\n       * @param {Function} callback\n       * @return {Function}\n       */\n\n\n      function listener(element, selector, type, callback) {\n        return function (e) {\n          e.delegateTarget = closest(e.target, selector);\n\n          if (e.delegateTarget) {\n            callback.call(element, e);\n          }\n        };\n      }\n\n      module.exports = delegate;\n      /***/\n    },\n    /* 7 */\n\n    /***/\n    function (module, exports) {\n      var DOCUMENT_NODE_TYPE = 9;\n      /**\n       * A polyfill for Element.matches()\n       */\n\n      if (typeof Element !== 'undefined' && !Element.prototype.matches) {\n        var proto = Element.prototype;\n        proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;\n      }\n      /**\n       * Finds the closest parent that matches a selector.\n       *\n       * @param {Element} element\n       * @param {String} selector\n       * @return {Function}\n       */\n\n\n      function closest(element, selector) {\n        while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {\n          if (typeof element.matches === 'function' && element.matches(selector)) {\n            return element;\n          }\n\n          element = element.parentNode;\n        }\n      }\n\n      module.exports = closest;\n      /***/\n    }])\n  );\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2xpcGJvYXJkL2Rpc3QvY2xpcGJvYXJkLmpzP2IzMTEiXSwibmFtZXMiOlsid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImkiLCJsIiwiY2FsbCIsIm0iLCJjIiwiZCIsIm5hbWUiLCJnZXR0ZXIiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiciIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidmFsdWUiLCJ0IiwibW9kZSIsIl9fZXNNb2R1bGUiLCJucyIsImNyZWF0ZSIsImtleSIsImJpbmQiLCJuIiwiZ2V0RGVmYXVsdCIsImdldE1vZHVsZUV4cG9ydHMiLCJvYmplY3QiLCJwcm9wZXJ0eSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicCIsInMiLCJfdHlwZW9mIiwiaXRlcmF0b3IiLCJvYmoiLCJjb25zdHJ1Y3RvciIsIl9jcmVhdGVDbGFzcyIsImRlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImxlbmd0aCIsImRlc2NyaXB0b3IiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NsaXBib2FyZEFjdGlvbiIsIl9jbGlwYm9hcmRBY3Rpb24yIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl90aW55RW1pdHRlciIsIl90aW55RW1pdHRlcjIiLCJfZ29vZExpc3RlbmVyIiwiX2dvb2RMaXN0ZW5lcjIiLCJkZWZhdWx0IiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJUeXBlRXJyb3IiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQ2xpcGJvYXJkIiwiX0VtaXR0ZXIiLCJ0cmlnZ2VyIiwib3B0aW9ucyIsIl90aGlzIiwiZ2V0UHJvdG90eXBlT2YiLCJyZXNvbHZlT3B0aW9ucyIsImxpc3RlbkNsaWNrIiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwiYWN0aW9uIiwiZGVmYXVsdEFjdGlvbiIsImRlZmF1bHRUYXJnZXQiLCJ0ZXh0IiwiZGVmYXVsdFRleHQiLCJjb250YWluZXIiLCJkb2N1bWVudCIsImJvZHkiLCJfdGhpczIiLCJsaXN0ZW5lciIsImUiLCJvbkNsaWNrIiwiZGVsZWdhdGVUYXJnZXQiLCJjdXJyZW50VGFyZ2V0IiwiY2xpcGJvYXJkQWN0aW9uIiwiZW1pdHRlciIsImdldEF0dHJpYnV0ZVZhbHVlIiwic2VsZWN0b3IiLCJxdWVyeVNlbGVjdG9yIiwiZGVzdHJveSIsImlzU3VwcG9ydGVkIiwiYWN0aW9ucyIsInN1cHBvcnQiLCJxdWVyeUNvbW1hbmRTdXBwb3J0ZWQiLCJmb3JFYWNoIiwic3VmZml4IiwiZWxlbWVudCIsImF0dHJpYnV0ZSIsImhhc0F0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsIl9zZWxlY3QiLCJfc2VsZWN0MiIsIkNsaXBib2FyZEFjdGlvbiIsImluaXRTZWxlY3Rpb24iLCJzZWxlY3RlZFRleHQiLCJzZWxlY3RGYWtlIiwic2VsZWN0VGFyZ2V0IiwiaXNSVEwiLCJkb2N1bWVudEVsZW1lbnQiLCJyZW1vdmVGYWtlIiwiZmFrZUhhbmRsZXJDYWxsYmFjayIsImZha2VIYW5kbGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImZha2VFbGVtIiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwiZm9udFNpemUiLCJib3JkZXIiLCJwYWRkaW5nIiwibWFyZ2luIiwicG9zaXRpb24iLCJ5UG9zaXRpb24iLCJ3aW5kb3ciLCJwYWdlWU9mZnNldCIsInNjcm9sbFRvcCIsInRvcCIsInNldEF0dHJpYnV0ZSIsImFwcGVuZENoaWxkIiwiY29weVRleHQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVtb3ZlQ2hpbGQiLCJzdWNjZWVkZWQiLCJleGVjQ29tbWFuZCIsImVyciIsImhhbmRsZVJlc3VsdCIsImVtaXQiLCJjbGVhclNlbGVjdGlvbiIsImZvY3VzIiwiZ2V0U2VsZWN0aW9uIiwicmVtb3ZlQWxsUmFuZ2VzIiwic2V0IiwiX2FjdGlvbiIsIkVycm9yIiwibm9kZVR5cGUiLCJfdGFyZ2V0Iiwic2VsZWN0Iiwibm9kZU5hbWUiLCJpc1JlYWRPbmx5Iiwic2V0U2VsZWN0aW9uUmFuZ2UiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZWxlY3Rpb24iLCJyYW5nZSIsImNyZWF0ZVJhbmdlIiwic2VsZWN0Tm9kZUNvbnRlbnRzIiwiYWRkUmFuZ2UiLCJ0b1N0cmluZyIsIkUiLCJvbiIsImNhbGxiYWNrIiwiY3R4IiwicHVzaCIsImZuIiwib25jZSIsIm9mZiIsImFwcGx5IiwiXyIsImRhdGEiLCJzbGljZSIsImV2dEFyciIsImxlbiIsImV2dHMiLCJsaXZlRXZlbnRzIiwiaXMiLCJkZWxlZ2F0ZSIsImxpc3RlbiIsInR5cGUiLCJzdHJpbmciLCJub2RlIiwibGlzdGVuTm9kZSIsIm5vZGVMaXN0IiwibGlzdGVuTm9kZUxpc3QiLCJsaXN0ZW5TZWxlY3RvciIsIkFycmF5IiwiSFRNTEVsZW1lbnQiLCJTdHJpbmciLCJjbG9zZXN0IiwiX2RlbGVnYXRlIiwidXNlQ2FwdHVyZSIsImxpc3RlbmVyRm4iLCJlbGVtZW50cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJtYXAiLCJET0NVTUVOVF9OT0RFX1RZUEUiLCJFbGVtZW50IiwibWF0Y2hlcyIsInByb3RvIiwibWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJvTWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwicGFyZW50Tm9kZSJdLCJtYXBwaW5n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QUFDRCxPQUFOLEdBQWdCQyxLQUFLLENBQUNDLGVBQU4sSUFDQUQsS0FBSyxDQUFDRSxrQkFETixJQUVBRixLQUFLLENBQUNHLGlCQUZOLElBR0FILEtBQUssQ0FBQ0ksZ0JBSE4sSUFJQUosS0FBSyxDQUFDSyxxQkFKdEI7QUFLSDtBQUVEOzs7Ozs7Ozs7QUFPQSxlQUFTZixPQUFULENBQWtCekYsT0FBbEIsRUFBMkJULFFBQTNCLEVBQXFDO0FBQ2pDLGVBQU9TLE9BQU8sSUFBSUEsT0FBTyxDQUFDK0MsUUFBUixLQUFxQmlELGtCQUF2QyxFQUEyRDtBQUN2RCxjQUFJLE9BQU9oRyxPQUFPLENBQUNrRyxPQUFmLEtBQTJCLFVBQTNCLElBQ0FsRyxPQUFPLENBQUNrRyxPQUFSLENBQWdCM0csUUFBaEIsQ0FESixFQUMrQjtBQUM3QixtQkFBT1MsT0FBUDtBQUNEOztBQUNEQSxpQkFBTyxHQUFHQSxPQUFPLENBQUN5RyxVQUFsQjtBQUNIO0FBQ0o7O0FBRUR0TixZQUFNLENBQUNELE9BQVAsR0FBaUJ1TSxPQUFqQjtBQUdBO0FBQU8sS0F6MkJHLENBdEZNO0FBQWhCO0FBaThCQyxDQTM4QkQsRSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jbGlwYm9hcmQvZGlzdC9jbGlwYm9hcmQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGNsaXBib2FyZC5qcyB2Mi4wLjRcbiAqIGh0dHBzOi8vemVub3JvY2hhLmdpdGh1Yi5pby9jbGlwYm9hcmQuanNcbiAqIFxuICogTGljZW5zZWQgTUlUIMKpIFplbm8gUm9jaGFcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiQ2xpcGJvYXJkSlNcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiQ2xpcGJvYXJkSlNcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfY2xpcGJvYXJkQWN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9jbGlwYm9hcmRBY3Rpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xpcGJvYXJkQWN0aW9uKTtcblxudmFyIF90aW55RW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBfdGlueUVtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGlueUVtaXR0ZXIpO1xuXG52YXIgX2dvb2RMaXN0ZW5lciA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfZ29vZExpc3RlbmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dvb2RMaXN0ZW5lcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIHdoaWNoIHRha2VzIG9uZSBvciBtb3JlIGVsZW1lbnRzLCBhZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGVtLFxuICogYW5kIGluc3RhbnRpYXRlcyBhIG5ldyBgQ2xpcGJvYXJkQWN0aW9uYCBvbiBlYWNoIGNsaWNrLlxuICovXG52YXIgQ2xpcGJvYXJkID0gZnVuY3Rpb24gKF9FbWl0dGVyKSB7XG4gICAgX2luaGVyaXRzKENsaXBib2FyZCwgX0VtaXR0ZXIpO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8SFRNTEVsZW1lbnR8SFRNTENvbGxlY3Rpb258Tm9kZUxpc3R9IHRyaWdnZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENsaXBib2FyZCh0cmlnZ2VyLCBvcHRpb25zKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbGlwYm9hcmQpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDbGlwYm9hcmQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDbGlwYm9hcmQpKS5jYWxsKHRoaXMpKTtcblxuICAgICAgICBfdGhpcy5yZXNvbHZlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgX3RoaXMubGlzdGVuQ2xpY2sodHJpZ2dlcik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGlmIGF0dHJpYnV0ZXMgd291bGQgYmUgcmVzb2x2ZWQgdXNpbmcgaW50ZXJuYWwgc2V0dGVyIGZ1bmN0aW9uc1xuICAgICAqIG9yIGN1c3RvbSBmdW5jdGlvbnMgdGhhdCB3ZXJlIHBhc3NlZCBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKENsaXBib2FyZCwgW3tcbiAgICAgICAga2V5OiAncmVzb2x2ZU9wdGlvbnMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZU9wdGlvbnMoKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgIHRoaXMuYWN0aW9uID0gdHlwZW9mIG9wdGlvbnMuYWN0aW9uID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5hY3Rpb24gOiB0aGlzLmRlZmF1bHRBY3Rpb247XG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHR5cGVvZiBvcHRpb25zLnRhcmdldCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMudGFyZ2V0IDogdGhpcy5kZWZhdWx0VGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gdHlwZW9mIG9wdGlvbnMudGV4dCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMudGV4dCA6IHRoaXMuZGVmYXVsdFRleHQ7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IF90eXBlb2Yob3B0aW9ucy5jb250YWluZXIpID09PSAnb2JqZWN0JyA/IG9wdGlvbnMuY29udGFpbmVyIDogZG9jdW1lbnQuYm9keTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIGEgY2xpY2sgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIHBhc3NlZCB0cmlnZ2VyLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xIVE1MRWxlbWVudHxIVE1MQ29sbGVjdGlvbnxOb2RlTGlzdH0gdHJpZ2dlclxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbGlzdGVuQ2xpY2snLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGlzdGVuQ2xpY2sodHJpZ2dlcikge1xuICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXIgPSAoMCwgX2dvb2RMaXN0ZW5lcjIuZGVmYXVsdCkodHJpZ2dlciwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLm9uQ2xpY2soZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIGEgbmV3IGBDbGlwYm9hcmRBY3Rpb25gIG9uIGVhY2ggY2xpY2sgZXZlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ29uQ2xpY2snLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgICAgICB2YXIgdHJpZ2dlciA9IGUuZGVsZWdhdGVUYXJnZXQgfHwgZS5jdXJyZW50VGFyZ2V0O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jbGlwYm9hcmRBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBib2FyZEFjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY2xpcGJvYXJkQWN0aW9uID0gbmV3IF9jbGlwYm9hcmRBY3Rpb24yLmRlZmF1bHQoe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogdGhpcy5hY3Rpb24odHJpZ2dlciksXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLnRhcmdldCh0cmlnZ2VyKSxcbiAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLnRleHQodHJpZ2dlciksXG4gICAgICAgICAgICAgICAgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICB0cmlnZ2VyOiB0cmlnZ2VyLFxuICAgICAgICAgICAgICAgIGVtaXR0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHQgYGFjdGlvbmAgbG9va3VwIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRyaWdnZXJcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2RlZmF1bHRBY3Rpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVmYXVsdEFjdGlvbih0cmlnZ2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QXR0cmlidXRlVmFsdWUoJ2FjdGlvbicsIHRyaWdnZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHQgYHRhcmdldGAgbG9va3VwIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRyaWdnZXJcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2RlZmF1bHRUYXJnZXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVmYXVsdFRhcmdldCh0cmlnZ2VyKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBnZXRBdHRyaWJ1dGVWYWx1ZSgndGFyZ2V0JywgdHJpZ2dlcik7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBzdXBwb3J0IG9mIHRoZSBnaXZlbiBhY3Rpb24sIG9yIGFsbCBhY3Rpb25zIGlmIG5vIGFjdGlvbiBpc1xuICAgICAgICAgKiBnaXZlbi5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFthY3Rpb25dXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkZWZhdWx0VGV4dCcsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBgdGV4dGAgbG9va3VwIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRyaWdnZXJcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZWZhdWx0VGV4dCh0cmlnZ2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QXR0cmlidXRlVmFsdWUoJ3RleHQnLCB0cmlnZ2VyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXN0cm95IGxpZmVjeWNsZS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXIuZGVzdHJveSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jbGlwYm9hcmRBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBib2FyZEFjdGlvbi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGlwYm9hcmRBY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogJ2lzU3VwcG9ydGVkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogWydjb3B5JywgJ2N1dCddO1xuXG4gICAgICAgICAgICB2YXIgYWN0aW9ucyA9IHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnID8gW2FjdGlvbl0gOiBhY3Rpb247XG4gICAgICAgICAgICB2YXIgc3VwcG9ydCA9ICEhZG9jdW1lbnQucXVlcnlDb21tYW5kU3VwcG9ydGVkO1xuXG4gICAgICAgICAgICBhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgICAgIHN1cHBvcnQgPSBzdXBwb3J0ICYmICEhZG9jdW1lbnQucXVlcnlDb21tYW5kU3VwcG9ydGVkKGFjdGlvbik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnQ7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ2xpcGJvYXJkO1xufShfdGlueUVtaXR0ZXIyLmRlZmF1bHQpO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byByZXRyaWV2ZSBhdHRyaWJ1dGUgdmFsdWUuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3VmZml4XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZVZhbHVlKHN1ZmZpeCwgZWxlbWVudCkge1xuICAgIHZhciBhdHRyaWJ1dGUgPSAnZGF0YS1jbGlwYm9hcmQtJyArIHN1ZmZpeDtcblxuICAgIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xpcGJvYXJkO1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3NlbGVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfc2VsZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NlbGVjdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogSW5uZXIgY2xhc3Mgd2hpY2ggcGVyZm9ybXMgc2VsZWN0aW9uIGZyb20gZWl0aGVyIGB0ZXh0YCBvciBgdGFyZ2V0YFxuICogcHJvcGVydGllcyBhbmQgdGhlbiBleGVjdXRlcyBjb3B5IG9yIGN1dCBvcGVyYXRpb25zLlxuICovXG52YXIgQ2xpcGJvYXJkQWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2xpcGJvYXJkQWN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsaXBib2FyZEFjdGlvbik7XG5cbiAgICAgICAgdGhpcy5yZXNvbHZlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5pbml0U2VsZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBiYXNlIHByb3BlcnRpZXMgcGFzc2VkIGZyb20gY29uc3RydWN0b3IuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKENsaXBib2FyZEFjdGlvbiwgW3tcbiAgICAgICAga2V5OiAncmVzb2x2ZU9wdGlvbnMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZU9wdGlvbnMoKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgIHRoaXMuYWN0aW9uID0gb3B0aW9ucy5hY3Rpb247XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyO1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyID0gb3B0aW9ucy5lbWl0dGVyO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBvcHRpb25zLnRhcmdldDtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IG9wdGlvbnMudGV4dDtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlciA9IG9wdGlvbnMudHJpZ2dlcjtcblxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFRleHQgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNpZGVzIHdoaWNoIHNlbGVjdGlvbiBzdHJhdGVneSBpcyBnb2luZyB0byBiZSBhcHBsaWVkIGJhc2VkXG4gICAgICAgICAqIG9uIHRoZSBleGlzdGVuY2Ugb2YgYHRleHRgIGFuZCBgdGFyZ2V0YCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaW5pdFNlbGVjdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0U2VsZWN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0RmFrZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0VGFyZ2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGZha2UgdGV4dGFyZWEgZWxlbWVudCwgc2V0cyBpdHMgdmFsdWUgZnJvbSBgdGV4dGAgcHJvcGVydHksXG4gICAgICAgICAqIGFuZCBtYWtlcyBhIHNlbGVjdGlvbiBvbiBpdC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NlbGVjdEZha2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0RmFrZSgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBpc1JUTCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RpcicpID09ICdydGwnO1xuXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUZha2UoKTtcblxuICAgICAgICAgICAgdGhpcy5mYWtlSGFuZGxlckNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZW1vdmVGYWtlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5mYWtlSGFuZGxlciA9IHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5mYWtlSGFuZGxlckNhbGxiYWNrKSB8fCB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLmZha2VFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgem9vbWluZyBvbiBpT1NcbiAgICAgICAgICAgIHRoaXMuZmFrZUVsZW0uc3R5bGUuZm9udFNpemUgPSAnMTJwdCc7XG4gICAgICAgICAgICAvLyBSZXNldCBib3ggbW9kZWxcbiAgICAgICAgICAgIHRoaXMuZmFrZUVsZW0uc3R5bGUuYm9yZGVyID0gJzAnO1xuICAgICAgICAgICAgdGhpcy5mYWtlRWxlbS5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgICAgICAgICAgdGhpcy5mYWtlRWxlbS5zdHlsZS5tYXJnaW4gPSAnMCc7XG4gICAgICAgICAgICAvLyBNb3ZlIGVsZW1lbnQgb3V0IG9mIHNjcmVlbiBob3Jpem9udGFsbHlcbiAgICAgICAgICAgIHRoaXMuZmFrZUVsZW0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgdGhpcy5mYWtlRWxlbS5zdHlsZVtpc1JUTCA/ICdyaWdodCcgOiAnbGVmdCddID0gJy05OTk5cHgnO1xuICAgICAgICAgICAgLy8gTW92ZSBlbGVtZW50IHRvIHRoZSBzYW1lIHBvc2l0aW9uIHZlcnRpY2FsbHlcbiAgICAgICAgICAgIHZhciB5UG9zaXRpb24gPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICAgIHRoaXMuZmFrZUVsZW0uc3R5bGUudG9wID0geVBvc2l0aW9uICsgJ3B4JztcblxuICAgICAgICAgICAgdGhpcy5mYWtlRWxlbS5zZXRBdHRyaWJ1dGUoJ3JlYWRvbmx5JywgJycpO1xuICAgICAgICAgICAgdGhpcy5mYWtlRWxlbS52YWx1ZSA9IHRoaXMudGV4dDtcblxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5mYWtlRWxlbSk7XG5cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRUZXh0ID0gKDAsIF9zZWxlY3QyLmRlZmF1bHQpKHRoaXMuZmFrZUVsZW0pO1xuICAgICAgICAgICAgdGhpcy5jb3B5VGV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ubHkgcmVtb3ZlcyB0aGUgZmFrZSBlbGVtZW50IGFmdGVyIGFub3RoZXIgY2xpY2sgZXZlbnQsIHRoYXQgd2F5XG4gICAgICAgICAqIGEgdXNlciBjYW4gaGl0IGBDdHJsK0NgIHRvIGNvcHkgYmVjYXVzZSBzZWxlY3Rpb24gc3RpbGwgZXhpc3RzLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVtb3ZlRmFrZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVGYWtlKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmFrZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuZmFrZUhhbmRsZXJDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWtlSGFuZGxlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWtlSGFuZGxlckNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuZmFrZUVsZW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmZha2VFbGVtKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZha2VFbGVtID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWxlY3RzIHRoZSBjb250ZW50IGZyb20gZWxlbWVudCBwYXNzZWQgb24gYHRhcmdldGAgcHJvcGVydHkuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZWxlY3RUYXJnZXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0VGFyZ2V0KCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFRleHQgPSAoMCwgX3NlbGVjdDIuZGVmYXVsdCkodGhpcy50YXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5jb3B5VGV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4ZWN1dGVzIHRoZSBjb3B5IG9wZXJhdGlvbiBiYXNlZCBvbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjb3B5VGV4dCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5VGV4dCgpIHtcbiAgICAgICAgICAgIHZhciBzdWNjZWVkZWQgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3VjY2VlZGVkID0gZG9jdW1lbnQuZXhlY0NvbW1hbmQodGhpcy5hY3Rpb24pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgc3VjY2VlZGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzdWx0KHN1Y2NlZWRlZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgYW4gZXZlbnQgYmFzZWQgb24gdGhlIGNvcHkgb3BlcmF0aW9uIHJlc3VsdC5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBzdWNjZWVkZWRcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2hhbmRsZVJlc3VsdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVSZXN1bHQoc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZW1pdChzdWNjZWVkZWQgPyAnc3VjY2VzcycgOiAnZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiB0aGlzLmFjdGlvbixcbiAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLnNlbGVjdGVkVGV4dCxcbiAgICAgICAgICAgICAgICB0cmlnZ2VyOiB0aGlzLnRyaWdnZXIsXG4gICAgICAgICAgICAgICAgY2xlYXJTZWxlY3Rpb246IHRoaXMuY2xlYXJTZWxlY3Rpb24uYmluZCh0aGlzKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogTW92ZXMgZm9jdXMgYXdheSBmcm9tIGB0YXJnZXRgIGFuZCBiYWNrIHRvIHRoZSB0cmlnZ2VyLCByZW1vdmVzIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2xlYXJTZWxlY3Rpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJTZWxlY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50cmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBgYWN0aW9uYCB0byBiZSBwZXJmb3JtZWQgd2hpY2ggY2FuIGJlIGVpdGhlciAnY29weScgb3IgJ2N1dCcuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Rlc3Ryb3knLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlc3Ryb3kgbGlmZWN5Y2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUZha2UoKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYWN0aW9uJyxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoKSB7XG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnY29weSc7XG5cbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbiA9IGFjdGlvbjtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGlvbiAhPT0gJ2NvcHknICYmIHRoaXMuX2FjdGlvbiAhPT0gJ2N1dCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgXCJhY3Rpb25cIiB2YWx1ZSwgdXNlIGVpdGhlciBcImNvcHlcIiBvciBcImN1dFwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgYGFjdGlvbmAgcHJvcGVydHkuXG4gICAgICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgICxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGB0YXJnZXRgIHByb3BlcnR5IHVzaW5nIGFuIGVsZW1lbnRcbiAgICAgICAgICogdGhhdCB3aWxsIGJlIGhhdmUgaXRzIGNvbnRlbnQgY29waWVkLlxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndGFyZ2V0JyxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICYmICh0eXBlb2YgdGFyZ2V0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0YXJnZXQpKSA9PT0gJ29iamVjdCcgJiYgdGFyZ2V0Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGlvbiA9PT0gJ2NvcHknICYmIHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBcInRhcmdldFwiIGF0dHJpYnV0ZS4gUGxlYXNlIHVzZSBcInJlYWRvbmx5XCIgaW5zdGVhZCBvZiBcImRpc2FibGVkXCIgYXR0cmlidXRlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hY3Rpb24gPT09ICdjdXQnICYmICh0YXJnZXQuaGFzQXR0cmlidXRlKCdyZWFkb25seScpIHx8IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgXCJ0YXJnZXRcIiBhdHRyaWJ1dGUuIFlvdSBjYW5cXCd0IGN1dCB0ZXh0IGZyb20gZWxlbWVudHMgd2l0aCBcInJlYWRvbmx5XCIgb3IgXCJkaXNhYmxlZFwiIGF0dHJpYnV0ZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgXCJ0YXJnZXRcIiB2YWx1ZSwgdXNlIGEgdmFsaWQgRWxlbWVudCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBgdGFyZ2V0YCBwcm9wZXJ0eS5cbiAgICAgICAgICogQHJldHVybiB7U3RyaW5nfEhUTUxFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90YXJnZXQ7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ2xpcGJvYXJkQWN0aW9uO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsaXBib2FyZEFjdGlvbjtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmZ1bmN0aW9uIHNlbGVjdChlbGVtZW50KSB7XG4gICAgdmFyIHNlbGVjdGVkVGV4dDtcblxuICAgIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnU0VMRUNUJykge1xuICAgICAgICBlbGVtZW50LmZvY3VzKCk7XG5cbiAgICAgICAgc2VsZWN0ZWRUZXh0ID0gZWxlbWVudC52YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0lOUFVUJyB8fCBlbGVtZW50Lm5vZGVOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICAgIHZhciBpc1JlYWRPbmx5ID0gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3JlYWRvbmx5Jyk7XG5cbiAgICAgICAgaWYgKCFpc1JlYWRPbmx5KSB7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgncmVhZG9ubHknLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LnNlbGVjdCgpO1xuICAgICAgICBlbGVtZW50LnNldFNlbGVjdGlvblJhbmdlKDAsIGVsZW1lbnQudmFsdWUubGVuZ3RoKTtcblxuICAgICAgICBpZiAoIWlzUmVhZE9ubHkpIHtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdyZWFkb25seScpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZWN0ZWRUZXh0ID0gZWxlbWVudC52YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG5cbiAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGVsZW1lbnQpO1xuICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG5cbiAgICAgICAgc2VsZWN0ZWRUZXh0ID0gc2VsZWN0aW9uLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGVjdGVkVGV4dDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZWxlY3Q7XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmZ1bmN0aW9uIEUgKCkge1xuICAvLyBLZWVwIHRoaXMgZW1wdHkgc28gaXQncyBlYXNpZXIgdG8gaW5oZXJpdCBmcm9tXG4gIC8vICh2aWEgaHR0cHM6Ly9naXRodWIuY29tL2xpcHNtYWNrIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Njb3R0Y29yZ2FuL3RpbnktZW1pdHRlci9pc3N1ZXMvMylcbn1cblxuRS5wcm90b3R5cGUgPSB7XG4gIG9uOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2ssIGN0eCkge1xuICAgIHZhciBlID0gdGhpcy5lIHx8ICh0aGlzLmUgPSB7fSk7XG5cbiAgICAoZVtuYW1lXSB8fCAoZVtuYW1lXSA9IFtdKSkucHVzaCh7XG4gICAgICBmbjogY2FsbGJhY2ssXG4gICAgICBjdHg6IGN0eFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgb25jZTogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrLCBjdHgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgZnVuY3Rpb24gbGlzdGVuZXIgKCkge1xuICAgICAgc2VsZi5vZmYobmFtZSwgbGlzdGVuZXIpO1xuICAgICAgY2FsbGJhY2suYXBwbHkoY3R4LCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBsaXN0ZW5lci5fID0gY2FsbGJhY2tcbiAgICByZXR1cm4gdGhpcy5vbihuYW1lLCBsaXN0ZW5lciwgY3R4KTtcbiAgfSxcblxuICBlbWl0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBkYXRhID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHZhciBldnRBcnIgPSAoKHRoaXMuZSB8fCAodGhpcy5lID0ge30pKVtuYW1lXSB8fCBbXSkuc2xpY2UoKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGV2dEFyci5sZW5ndGg7XG5cbiAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xuICAgICAgZXZ0QXJyW2ldLmZuLmFwcGx5KGV2dEFycltpXS5jdHgsIGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG9mZjogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGUgPSB0aGlzLmUgfHwgKHRoaXMuZSA9IHt9KTtcbiAgICB2YXIgZXZ0cyA9IGVbbmFtZV07XG4gICAgdmFyIGxpdmVFdmVudHMgPSBbXTtcblxuICAgIGlmIChldnRzICYmIGNhbGxiYWNrKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXZ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoZXZ0c1tpXS5mbiAhPT0gY2FsbGJhY2sgJiYgZXZ0c1tpXS5mbi5fICE9PSBjYWxsYmFjaylcbiAgICAgICAgICBsaXZlRXZlbnRzLnB1c2goZXZ0c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGV2ZW50IGZyb20gcXVldWUgdG8gcHJldmVudCBtZW1vcnkgbGVha1xuICAgIC8vIFN1Z2dlc3RlZCBieSBodHRwczovL2dpdGh1Yi5jb20vbGF6ZFxuICAgIC8vIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL3Njb3R0Y29yZ2FuL3RpbnktZW1pdHRlci9jb21taXQvYzZlYmZhYTliYzk3M2IzM2QxMTBhODRhMzA3NzQyYjdjZjk0Yzk1MyNjb21taXRjb21tZW50LTUwMjQ5MTBcblxuICAgIChsaXZlRXZlbnRzLmxlbmd0aClcbiAgICAgID8gZVtuYW1lXSA9IGxpdmVFdmVudHNcbiAgICAgIDogZGVsZXRlIGVbbmFtZV07XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFO1xuXG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIGRlbGVnYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgYWxsIHBhcmFtcyBhbmQgY2FsbHMgdGhlIHJpZ2h0XG4gKiBsaXN0ZW5lciBmdW5jdGlvbiBiYXNlZCBvbiBpdHMgdGFyZ2V0IHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8SFRNTEVsZW1lbnR8SFRNTENvbGxlY3Rpb258Tm9kZUxpc3R9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0YXJnZXQgJiYgIXR5cGUgJiYgIWNhbGxiYWNrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBhcmd1bWVudHMnKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIFN0cmluZycpO1xuICAgIH1cblxuICAgIGlmICghaXMuZm4oY2FsbGJhY2spKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXJkIGFyZ3VtZW50IG11c3QgYmUgYSBGdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChpcy5ub2RlKHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIGxpc3Rlbk5vZGUodGFyZ2V0LCB0eXBlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzLm5vZGVMaXN0KHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIGxpc3Rlbk5vZGVMaXN0KHRhcmdldCwgdHlwZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBlbHNlIGlmIChpcy5zdHJpbmcodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gbGlzdGVuU2VsZWN0b3IodGFyZ2V0LCB0eXBlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgU3RyaW5nLCBIVE1MRWxlbWVudCwgSFRNTENvbGxlY3Rpb24sIG9yIE5vZGVMaXN0Jyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYSBIVE1MIGVsZW1lbnRcbiAqIGFuZCByZXR1cm5zIGEgcmVtb3ZlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBsaXN0ZW5Ob2RlKG5vZGUsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYSBsaXN0IG9mIEhUTUwgZWxlbWVudHNcbiAqIGFuZCByZXR1cm5zIGEgcmVtb3ZlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Tm9kZUxpc3R8SFRNTENvbGxlY3Rpb259IG5vZGVMaXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gbGlzdGVuTm9kZUxpc3Qobm9kZUxpc3QsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChub2RlTGlzdCwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKG5vZGVMaXN0LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEFkZCBhbiBldmVudCBsaXN0ZW5lciB0byBhIHNlbGVjdG9yXG4gKiBhbmQgcmV0dXJucyBhIHJlbW92ZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBsaXN0ZW5TZWxlY3RvcihzZWxlY3RvciwgdHlwZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZGVsZWdhdGUoZG9jdW1lbnQuYm9keSwgc2VsZWN0b3IsIHR5cGUsIGNhbGxiYWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0ZW47XG5cblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQ2hlY2sgaWYgYXJndW1lbnQgaXMgYSBIVE1MIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLm5vZGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICYmIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnRcbiAgICAgICAgJiYgdmFsdWUubm9kZVR5cGUgPT09IDE7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGFyZ3VtZW50IGlzIGEgbGlzdCBvZiBIVE1MIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5ub2RlTGlzdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWRcbiAgICAgICAgJiYgKHR5cGUgPT09ICdbb2JqZWN0IE5vZGVMaXN0XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgSFRNTENvbGxlY3Rpb25dJylcbiAgICAgICAgJiYgKCdsZW5ndGgnIGluIHZhbHVlKVxuICAgICAgICAmJiAodmFsdWUubGVuZ3RoID09PSAwIHx8IGV4cG9ydHMubm9kZSh2YWx1ZVswXSkpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhcmd1bWVudCBpcyBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuc3RyaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJ1xuICAgICAgICB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYXJndW1lbnQgaXMgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuZm4gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblxuICAgIHJldHVybiB0eXBlID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNsb3Nlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG4vKipcbiAqIERlbGVnYXRlcyBldmVudCB0byBhIHNlbGVjdG9yLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlQ2FwdHVyZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBfZGVsZWdhdGUoZWxlbWVudCwgc2VsZWN0b3IsIHR5cGUsIGNhbGxiYWNrLCB1c2VDYXB0dXJlKSB7XG4gICAgdmFyIGxpc3RlbmVyRm4gPSBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyRm4sIHVzZUNhcHR1cmUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXJGbiwgdXNlQ2FwdHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogRGVsZWdhdGVzIGV2ZW50IHRvIGEgc2VsZWN0b3IuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ3xBcnJheX0gW2VsZW1lbnRzXVxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlQ2FwdHVyZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBkZWxlZ2F0ZShlbGVtZW50cywgc2VsZWN0b3IsIHR5cGUsIGNhbGxiYWNrLCB1c2VDYXB0dXJlKSB7XG4gICAgLy8gSGFuZGxlIHRoZSByZWd1bGFyIEVsZW1lbnQgdXNhZ2VcbiAgICBpZiAodHlwZW9mIGVsZW1lbnRzLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIF9kZWxlZ2F0ZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBFbGVtZW50LWxlc3MgdXNhZ2UsIGl0IGRlZmF1bHRzIHRvIGdsb2JhbCBkZWxlZ2F0aW9uXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFVzZSBgZG9jdW1lbnRgIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIsIHRoZW4gYXBwbHkgYXJndW1lbnRzXG4gICAgICAgIC8vIFRoaXMgaXMgYSBzaG9ydCB3YXkgdG8gLnVuc2hpZnQgYGFyZ3VtZW50c2Agd2l0aG91dCBydW5uaW5nIGludG8gZGVvcHRpbWl6YXRpb25zXG4gICAgICAgIHJldHVybiBfZGVsZWdhdGUuYmluZChudWxsLCBkb2N1bWVudCkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgU2VsZWN0b3ItYmFzZWQgdXNhZ2VcbiAgICBpZiAodHlwZW9mIGVsZW1lbnRzID09PSAnc3RyaW5nJykge1xuICAgICAgICBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZWxlbWVudHMpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBBcnJheS1saWtlIGJhc2VkIHVzYWdlXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIF9kZWxlZ2F0ZShlbGVtZW50LCBzZWxlY3RvciwgdHlwZSwgY2FsbGJhY2ssIHVzZUNhcHR1cmUpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEZpbmRzIGNsb3Nlc3QgbWF0Y2ggYW5kIGludm9rZXMgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyKGVsZW1lbnQsIHNlbGVjdG9yLCB0eXBlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUuZGVsZWdhdGVUYXJnZXQgPSBjbG9zZXN0KGUudGFyZ2V0LCBzZWxlY3Rvcik7XG5cbiAgICAgICAgaWYgKGUuZGVsZWdhdGVUYXJnZXQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoZWxlbWVudCwgZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVsZWdhdGU7XG5cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBET0NVTUVOVF9OT0RFX1RZUEUgPSA5O1xuXG4vKipcbiAqIEEgcG9seWZpbGwgZm9yIEVsZW1lbnQubWF0Y2hlcygpXG4gKi9cbmlmICh0eXBlb2YgRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgIUVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMpIHtcbiAgICB2YXIgcHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZTtcblxuICAgIHByb3RvLm1hdGNoZXMgPSBwcm90by5tYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG8ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgIHByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgIHByb3RvLm9NYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBjbG9zZXN0IHBhcmVudCB0aGF0IG1hdGNoZXMgYSBzZWxlY3Rvci5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGNsb3Nlc3QgKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSAhPT0gRE9DVU1FTlRfTk9ERV9UWVBFKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWxlbWVudC5tYXRjaGVzID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICBlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvc2VzdDtcblxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/clipboard/dist/clipboard.js\n");

/***/ })

}]);